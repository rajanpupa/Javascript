{"jQuery.active":"0","jQuery.ajax":"function ( origSettings ) {\n\t\tvar s = jQuery.extend(true, {}, jQuery.ajaxSettings, origSettings);\n\t\t\n\t\tvar jsonp, status, data,\n\t\t\tcallbackContext = s.context || s,\n\t\t\ttype = s.type.toUpperCase();\n\n\t\t// convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param(s.data);\n\t\t}\n\n\t\t// Handle JSONP Parameter Callbacks\n\t\tif ( s.dataType === \"jsonp\" ) {\n\t\t\tif ( type === \"GET\" ) {\n\t\t\t\tif ( !jsre.test( s.url ) ) {\n\t\t\t\t\ts.url += (rquery.test( s.url ) ? \"&\" : \"?\") + (s.jsonp || \"callback\") + \"=?\";\n\t\t\t\t}\n\t\t\t} else if ( !s.data || !jsre.test(s.data) ) {\n\t\t\t\ts.data = (s.data ? s.data + \"&\" : \"\") + (s.jsonp || \"callback\") + \"=?\";\n\t\t\t}\n\t\t\ts.dataType = \"json\";\n\t\t}\n\n\t\t// Build temporary JSONP function\n\t\tif ( s.dataType === \"json\" && (s.data && jsre.test(s.data) || jsre.test(s.url)) ) {\n\t\t\tjsonp = s.jsonpCallback || (\"jsonp\" + jsc++);\n\n\t\t\t// Replace the =? sequence both in the query string and the data\n\t\t\tif ( s.data ) {\n\t\t\t\ts.data = (s.data + \"\").replace(jsre, \"=\" + jsonp + \"$1\");\n\t\t\t}\n\n\t\t\ts.url = s.url.replace(jsre, \"=\" + jsonp + \"$1\");\n\n\t\t\t// We need to make sure\n\t\t\t// that a JSONP style response is executed properly\n\t\t\ts.dataType = \"script\";\n\n\t\t\t// Handle JSONP-style loading\n\t\t\twindow[ jsonp ] = window[ jsonp ] || function(tmp){\n\t\t\t\tdata = tmp;\n\t\t\t\tsuccess();\n\t\t\t\tcomplete();\n\t\t\t\t// Garbage collect\n\t\t\t\twindow[ jsonp ] = undefined;\n\t\t\t\ttry{ delete window[ jsonp ]; } catch(e){}\n\t\t\t\tif ( head ) {\n\t\t\t\t\thead.removeChild( script );\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tif ( s.dataType === \"script\" && s.cache === null ) {\n\t\t\ts.cache = false;\n\t\t}\n\n\t\tif ( s.cache === false && type === \"GET\" ) {\n\t\t\tvar ts = now();\n\n\t\t\t// try replacing _= if it is there\n\t\t\tvar ret = s.url.replace(rts, \"$1_=\" + ts + \"$2\");\n\n\t\t\t// if nothing was replaced, add timestamp to the end\n\t\t\ts.url = ret + ((ret === s.url) ? (rquery.test(s.url) ? \"&\" : \"?\") + \"_=\" + ts : \"\");\n\t\t}\n\n\t\t// If data is available, append data to url for get requests\n\t\tif ( s.data && type === \"GET\" ) {\n\t\t\ts.url += (rquery.test(s.url) ? \"&\" : \"?\") + s.data;\n\t\t}\n\n\t\t// Watch for a new set of requests\n\t\tif ( s.global && ! jQuery.active++ ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Matches an absolute URL, and saves the domain\n\t\tvar parts = rurl.exec( s.url ),\n\t\t\tremote = parts && (parts[1] && parts[1] !== location.protocol || parts[2] !== location.host);\n\n\t\t// If we're requesting a remote document\n\t\t// and trying to load JSON or Script with a GET\n\t\tif ( s.dataType === \"script\" && type === \"GET\" && remote ) {\n\t\t\tvar head = document.getElementsByTagName(\"head\")[0] || document.documentElement;\n\t\t\tvar script = document.createElement(\"script\");\n\t\t\tscript.src = s.url;\n\t\t\tif ( s.scriptCharset ) {\n\t\t\t\tscript.charset = s.scriptCharset;\n\t\t\t}\n\n\t\t\t// Handle Script loading\n\t\t\tif ( !jsonp ) {\n\t\t\t\tvar done = false;\n\n\t\t\t\t// Attach handlers for all browsers\n\t\t\t\tscript.onload = script.onreadystatechange = function(){\n\t\t\t\t\tif ( !done && (!this.readyState ||\n\t\t\t\t\t\t\tthis.readyState === \"loaded\" || this.readyState === \"complete\") ) {\n\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\tsuccess();\n\t\t\t\t\t\tcomplete();\n\n\t\t\t\t\t\t// Handle memory leak in IE\n\t\t\t\t\t\tscript.onload = script.onreadystatechange = null;\n\t\t\t\t\t\tif ( head && script.parentNode ) {\n\t\t\t\t\t\t\thead.removeChild( script );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Use insertBefore instead of appendChild  to circumvent an IE6 bug.\n\t\t\t// This arises when a base node is used (#2709 and #4378).\n\t\t\thead.insertBefore( script, head.firstChild );\n\n\t\t\t// We handle everything using the script element injection\n\t\t\treturn undefined;\n\t\t}\n\n\t\tvar requestDone = false;\n\n\t\t// Create the request object\n\t\tvar xhr = s.xhr();\n\n\t\t// Open the socket\n\t\t// Passing null username, generates a login popup on Opera (#2865)\n\t\tif ( s.username ) {\n\t\t\txhr.open(type, s.url, s.async, s.username, s.password);\n\t\t} else {\n\t\t\txhr.open(type, s.url, s.async);\n\t\t}\n\n\t\t// Need an extra try/catch for cross domain requests in Firefox 3\n\t\ttry {\n\t\t\t// Set the correct header, if data is being sent\n\t\t\tif ( s.data || origSettings && origSettings.contentType ) {\n\t\t\t\txhr.setRequestHeader(\"Content-Type\", s.contentType);\n\t\t\t}\n\n\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\tif ( s.ifModified ) {\n\t\t\t\tif ( jQuery.lastModified[s.url] ) {\n\t\t\t\t\txhr.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[s.url]);\n\t\t\t\t}\n\n\t\t\t\tif ( jQuery.etag[s.url] ) {\n\t\t\t\t\txhr.setRequestHeader(\"If-None-Match\", jQuery.etag[s.url]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set header so the called script knows that it's an XMLHttpRequest\n\t\t\t// Only send the header if it's not a remote XHR\n\t\t\tif ( !remote ) {\n\t\t\t\txhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n\t\t\t}\n\n\t\t\t// Set the Accepts header for the server, depending on the dataType\n\t\t\txhr.setRequestHeader(\"Accept\", s.dataType && s.accepts[ s.dataType ] ?\n\t\t\t\ts.accepts[ s.dataType ] + \", */*\" :\n\t\t\t\ts.accepts._default );\n\t\t} catch(e){}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend && s.beforeSend.call(callbackContext, xhr, s) === false ) {\n\t\t\t// Handle the global AJAX counter\n\t\t\tif ( s.global && ! --jQuery.active ) {\n\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t}\n\n\t\t\t// close opended socket\n\t\t\txhr.abort();\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( s.global ) {\n\t\t\ttrigger(\"ajaxSend\", [xhr, s]);\n\t\t}\n\n\t\t// Wait for a response to come back\n\t\tvar onreadystatechange = function(isTimeout){\n\t\t\t// The request was aborted, clear the interval and decrement jQuery.active\n\t\t\tif ( !xhr || xhr.readyState === 0 ) {\n\t\t\t\tif ( ival ) {\n\t\t\t\t\t// clear poll interval\n\t\t\t\t\tclearInterval( ival );\n\t\t\t\t\tival = null;\n\n\t\t\t\t\t// Handle the global AJAX counter\n\t\t\t\t\tif ( s.global && ! --jQuery.active ) {\n\t\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// The transfer is complete and the data is available, or the request timed out\n\t\t\t} else if ( !requestDone && xhr && (xhr.readyState === 4 || isTimeout === \"timeout\") ) {\n\t\t\t\trequestDone = true;\n\n\t\t\t\t// clear poll interval\n\t\t\t\tif (ival) {\n\t\t\t\t\tclearInterval(ival);\n\t\t\t\t\tival = null;\n\t\t\t\t}\n\n\t\t\t\tstatus = isTimeout === \"timeout\" ?\n\t\t\t\t\t\"timeout\" :\n\t\t\t\t\t!jQuery.httpSuccess( xhr ) ?\n\t\t\t\t\t\t\"error\" :\n\t\t\t\t\t\ts.ifModified && jQuery.httpNotModified( xhr, s.url ) ?\n\t\t\t\t\t\t\t\"notmodified\" :\n\t\t\t\t\t\t\t\"success\";\n\n\t\t\t\tif ( status === \"success\" ) {\n\t\t\t\t\t// Watch for, and catch, XML document parse errors\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// process the data (runs the xml through httpData regardless of callback)\n\t\t\t\t\t\tdata = jQuery.httpData( xhr, s.dataType, s );\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\tstatus = \"parsererror\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Make sure that the request was successful or notmodified\n\t\t\t\tif ( status === \"success\" || status === \"notmodified\" ) {\n\t\t\t\t\t// JSONP handles its own success callback\n\t\t\t\t\tif ( !jsonp ) {\n\t\t\t\t\t\tsuccess();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tjQuery.handleError(s, xhr, status);\n\t\t\t\t}\n\n\t\t\t\t// Fire the complete handlers\n\t\t\t\tcomplete();\n\n\t\t\t\tif ( isTimeout === \"timeout\" ) {\n\t\t\t\t\txhr.abort();\n\t\t\t\t}\n\n\t\t\t\t// Stop memory leaks\n\t\t\t\tif ( s.async ) {\n\t\t\t\t\txhr = null;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tif ( s.async ) {\n\t\t\t// don't attach the handler to the request, just poll it instead\n\t\t\tvar ival = setInterval(onreadystatechange, 13);\n\n\t\t\t// Timeout checker\n\t\t\tif ( s.timeout > 0 ) {\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t// Check to see if the request is still happening\n\t\t\t\t\tif ( xhr && !requestDone ) {\n\t\t\t\t\t\tonreadystatechange( \"timeout\" );\n\t\t\t\t\t}\n\t\t\t\t}, s.timeout);\n\t\t\t}\n\t\t}\n\n\t\t// Send the data\n\t\ttry {\n\t\t\txhr.send( type === \"POST\" || type === \"PUT\" ? s.data : null );\n\t\t} catch(e) {\n\t\t\tjQuery.handleError(s, xhr, null, e);\n\t\t\t// Fire the complete handlers\n\t\t\tcomplete();\n\t\t}\n\n\t\t// firefox 1.5 doesn't fire statechange for sync requests\n\t\tif ( !s.async ) {\n\t\t\tonreadystatechange();\n\t\t}\n\n\t\tfunction success(){\n\t\t\t// If a local callback was specified, fire it and pass it the data\n\t\t\tif ( s.success ) {\n\t\t\t\ts.success.call( callbackContext, data, status, xhr );\n\t\t\t}\n\n\t\t\t// Fire the global callback\n\t\t\tif ( s.global ) {\n\t\t\t\ttrigger( \"ajaxSuccess\", [xhr, s] );\n\t\t\t}\n\t\t}\n\n\t\tfunction complete(){\n\t\t\t// Process result\n\t\t\tif ( s.complete ) {\n\t\t\t\ts.complete.call( callbackContext, xhr, status);\n\t\t\t}\n\n\t\t\t// The request was completed\n\t\t\tif ( s.global ) {\n\t\t\t\ttrigger( \"ajaxComplete\", [xhr, s] );\n\t\t\t}\n\n\t\t\t// Handle the global AJAX counter\n\t\t\tif ( s.global && ! --jQuery.active ) {\n\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction trigger(type, args){\n\t\t\t(s.context ? jQuery(s.context) : jQuery.event).trigger(type, args);\n\t\t}\n\n\t\t// return XMLHttpRequest to allow aborting the request etc.\n\t\treturn xhr;\n\t}","jQuery.ajaxSetup":"function ( settings ) {\n\t\tjQuery.extend( jQuery.ajaxSettings, settings );\n\t}","jQuery.attr":"function ( elem, name, value, pass ) {\n\t\t// don't set attributes on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif ( pass && name in jQuery.attrFn ) {\n\t\t\treturn jQuery(elem)[name](value);\n\t\t}\n\n\t\tvar notxml = elem.nodeType !== 1 || !jQuery.isXMLDoc( elem ),\n\t\t\t// Whether we are setting (or getting)\n\t\t\tset = value !== undefined;\n\n\t\t// Try to normalize/fix the name\n\t\tname = notxml && jQuery.props[ name ] || name;\n\n\t\t// Only do all the following if this is a node (faster for style)\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\t// These attributes require special treatment\n\t\t\tvar special = rspecialurl.test( name );\n\n\t\t\t// Safari mis-reports the default selected property of a hidden option\n\t\t\t// Accessing the parent's selectedIndex property fixes it\n\t\t\tif ( name === \"selected\" && elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\t// If applicable, access the attribute via the DOM 0 way\n\t\t\tif ( name in elem && notxml && !special ) {\n\t\t\t\tif ( set ) {\n\t\t\t\t\t// We can't allow the type property to be changed (since it causes problems in IE)\n\t\t\t\t\tif ( name === \"type\" && rtype.test( elem.nodeName ) && elem.parentNode ) {\n\t\t\t\t\t\tthrow \"type property can't be changed\";\n\t\t\t\t\t}\n\n\t\t\t\t\telem[ name ] = value;\n\t\t\t\t}\n\n\t\t\t\t// browsers index elements by id/name on forms, give priority to attributes.\n\t\t\t\tif ( jQuery.nodeName( elem, \"form\" ) && elem.getAttributeNode(name) ) {\n\t\t\t\t\treturn elem.getAttributeNode( name ).nodeValue;\n\t\t\t\t}\n\n\t\t\t\t// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set\n\t\t\t\t// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\tif ( name === \"tabIndex\" ) {\n\t\t\t\t\tvar attributeNode = elem.getAttributeNode( \"tabIndex\" );\n\n\t\t\t\t\treturn attributeNode && attributeNode.specified ?\n\t\t\t\t\t\tattributeNode.value :\n\t\t\t\t\t\trfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?\n\t\t\t\t\t\t\t0 :\n\t\t\t\t\t\t\tundefined;\n\t\t\t\t}\n\n\t\t\t\treturn elem[ name ];\n\t\t\t}\n\n\t\t\tif ( !jQuery.support.style && notxml && name === \"style\" ) {\n\t\t\t\tif ( set ) {\n\t\t\t\t\telem.style.cssText = \"\" + value;\n\t\t\t\t}\n\n\t\t\t\treturn elem.style.cssText;\n\t\t\t}\n\n\t\t\tif ( set ) {\n\t\t\t\t// convert the value to a string (all browsers do this but IE) see #1070\n\t\t\t\telem.setAttribute( name, \"\" + value );\n\t\t\t}\n\n\t\t\tvar attr = !jQuery.support.hrefNormalized && notxml && special ?\n\t\t\t\t\t// Some attributes require a special call on IE\n\t\t\t\t\telem.getAttribute( name, 2 ) :\n\t\t\t\t\telem.getAttribute( name );\n\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn attr === null ? undefined : attr;\n\t\t}\n\n\t\t// elem is actually elem.style ... set the style\n\t\t// Using attr for specific style information is now deprecated. Use style insead.\n\t\treturn jQuery.style( elem, name, value );\n\t}","jQuery.bindReady":"function () {\n\t\tif ( readyBound ) { return; }\n\t\treadyBound = true;\n\n\t\t// Catch cases where $(document).ready() is called after the\n\t\t// browser event has already occurred.\n\t\tif ( document.readyState === \"complete\" ) {\n\t\t\treturn jQuery.ready();\n\t\t}\n\n\t\t// Mozilla, Opera and webkit nightlies currently support this event\n\t\tif ( document.addEventListener ) {\n\t\t\t// Use the handy event callback\n\t\t\tdocument.addEventListener( \"DOMContentLoaded\", DOMContentLoaded, false );\n\t\t\t\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.addEventListener( \"load\", jQuery.ready, false );\n\n\t\t// If IE event model is used\n\t\t} else if ( document.attachEvent ) {\n\t\t\t// ensure firing before onload,\n\t\t\t// maybe late but safe also for iframes\n\t\t\tdocument.attachEvent(\"onreadystatechange\", DOMContentLoaded);\n\t\t\t\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.attachEvent( \"onload\", jQuery.ready );\n\n\t\t\t// If IE and not a frame\n\t\t\t// continually check to see if the document is ready\n\t\t\tvar toplevel = false;\n\n\t\t\ttry {\n\t\t\t\ttoplevel = window.frameElement == null;\n\t\t\t} catch(e){}\n\n\t\t\tif ( document.documentElement.doScroll && toplevel ) {\n\t\t\t\tdoScrollCheck();\n\t\t\t}\n\t\t}\n\t}","jQuery.boxModel":"true","jQuery.clean":"function ( elems, context, fragment, scripts ) {\n\t\tcontext = context || document;\n\n\t\t// !context.createElement fails in IE with an error but returns typeof 'object'\n\t\tif ( typeof context.createElement === \"undefined\" ) {\n\t\t\tcontext = context.ownerDocument || context[0] && context[0].ownerDocument || document;\n\t\t}\n\n\t\tvar ret = [];\n\n\t\tjQuery.each(elems, function(i, elem){\n\t\t\tif ( typeof elem === \"number\" ) {\n\t\t\t\telem += '';\n\t\t\t}\n\n\t\t\tif ( !elem ) { return; }\n\n\t\t\t// Convert html string into DOM nodes\n\t\t\tif ( typeof elem === \"string\" && !rhtml.test( elem ) ) {\n\t\t\t\telem = context.createTextNode( elem );\n\n\t\t\t} else if ( typeof elem === \"string\" ) {\n\t\t\t\t// Fix \"XHTML\"-style tags in all browsers\n\t\t\t\telem = elem.replace(rxhtmlTag, fcloseTag);\n\n\t\t\t\t// Trim whitespace, otherwise indexOf won't work as expected\n\t\t\t\tvar tag = (rtagName.exec( elem ) || [\"\", \"\"])[1].toLowerCase(),\n\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default,\n\t\t\t\t\tdepth = wrap[0],\n\t\t\t\t\tdiv = context.createElement(\"div\");\n\n\t\t\t\t// Go to html and back, then peel off extra wrappers\n\t\t\t\tdiv.innerHTML = wrap[1] + elem + wrap[2];\n\n\t\t\t\t// Move to the right depth\n\t\t\t\twhile ( depth-- ) {\n\t\t\t\t\tdiv = div.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Remove IE's autoinserted <tbody> from table fragments\n\t\t\t\tif ( !jQuery.support.tbody ) {\n\n\t\t\t\t\t// String was a <table>, *may* have spurious <tbody>\n\t\t\t\t\tvar hasBody = rtbody.test(elem),\n\t\t\t\t\t\ttbody = tag === \"table\" && !hasBody ?\n\t\t\t\t\t\t\tdiv.firstChild && div.firstChild.childNodes :\n\n\t\t\t\t\t\t\t// String was a bare <thead> or <tfoot>\n\t\t\t\t\t\t\twrap[1] == \"<table>\" && !hasBody ?\n\t\t\t\t\t\t\t\tdiv.childNodes :\n\t\t\t\t\t\t\t\t[];\n\n\t\t\t\t\tfor ( var j = tbody.length - 1; j >= 0 ; --j ) {\n\t\t\t\t\t\tif ( jQuery.nodeName( tbody[ j ], \"tbody\" ) && !tbody[ j ].childNodes.length ) {\n\t\t\t\t\t\t\ttbody[ j ].parentNode.removeChild( tbody[ j ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// IE completely kills leading whitespace when innerHTML is used\n\t\t\t\tif ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {\n\t\t\t\t\tdiv.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );\n\t\t\t\t}\n\n\t\t\t\telem = jQuery.makeArray( div.childNodes );\n\t\t\t}\n\n\t\t\tif ( elem.nodeType ) {\n\t\t\t\tret.push( elem );\n\t\t\t} else {\n\t\t\t\tret = jQuery.merge( ret, elem );\n\t\t\t}\n\n\t\t});\n\n\t\tif ( fragment ) {\n\t\t\tfor ( var i = 0; ret[i]; i++ ) {\n\t\t\t\tif ( scripts && jQuery.nodeName( ret[i], \"script\" ) && (!ret[i].type || ret[i].type.toLowerCase() === \"text/javascript\") ) {\n\t\t\t\t\tscripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );\n\t\t\t\t} else {\n\t\t\t\t\tif ( ret[i].nodeType === 1 ) {\n\t\t\t\t\t\tret.splice.apply( ret, [i + 1, 0].concat(jQuery.makeArray(ret[i].getElementsByTagName(\"script\"))) );\n\t\t\t\t\t}\n\t\t\t\t\tfragment.appendChild( ret[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}","jQuery.contains":"function (a, b){\n\treturn a.compareDocumentPosition(b) & 16;\n}","jQuery.css":"function ( elem, name, force, extra ) {\n\t\tif ( name === \"width\" || name === \"height\" ) {\n\t\t\tvar val, props = { position: \"absolute\", visibility: \"hidden\", display:\"block\" }, which = name === \"width\" ? [ \"Left\", \"Right\" ] : [ \"Top\", \"Bottom\" ];\n\n\t\t\tfunction getWH() {\n\t\t\t\tval = name === \"width\" ? elem.offsetWidth : elem.offsetHeight;\n\n\t\t\t\tif ( extra === \"border\" ) { return; }\n\n\t\t\t\tjQuery.each( which, function() {\n\t\t\t\t\tif ( !extra ) {\n\t\t\t\t\t\tval -= parseFloat(jQuery.curCSS( elem, \"padding\" + this, true)) || 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( extra === \"margin\" ) {\n\t\t\t\t\t\tval += parseFloat(jQuery.curCSS( elem, \"margin\" + this, true)) || 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tval -= parseFloat(jQuery.curCSS( elem, \"border\" + this + \"Width\", true)) || 0;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( elem.offsetWidth !== 0 ) {\n\t\t\t\tgetWH();\n\t\t\t} else {\n\t\t\t\tjQuery.swap( elem, props, getWH );\n\t\t\t}\n\n\t\t\treturn Math.max(0, Math.round(val));\n\t\t}\n\n\t\treturn jQuery.curCSS( elem, name, force );\n\t}","jQuery.curCSS":"function ( elem, name, force ) {\n\t\tvar ret, style = elem.style, filter;\n\n\t\t// IE uses filters for opacity\n\t\tif ( !jQuery.support.opacity && name === \"opacity\" && elem.currentStyle ) {\n\t\t\tret = ropacity.test(elem.currentStyle.filter || \"\") ?\n\t\t\t\t(parseFloat(RegExp.$1) / 100) + \"\" :\n\t\t\t\t\"\";\n\n\t\t\treturn ret === \"\" ?\n\t\t\t\t\"1\" :\n\t\t\t\tret;\n\t\t}\n\n\t\t// Make sure we're using the right name for getting the float value\n\t\tif ( rfloat.test( name ) ) {\n\t\t\tname = styleFloat;\n\t\t}\n\n\t\tif ( !force && style && style[ name ] ) {\n\t\t\tret = style[ name ];\n\n\t\t} else if ( getComputedStyle ) {\n\n\t\t\t// Only \"float\" is needed here\n\t\t\tif ( rfloat.test( name ) ) {\n\t\t\t\tname = \"float\";\n\t\t\t}\n\n\t\t\tname = name.replace( rupper, \"-$1\" ).toLowerCase();\n\n\t\t\tvar defaultView = elem.ownerDocument.defaultView;\n\n\t\t\tif ( !defaultView ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar computedStyle = defaultView.getComputedStyle( elem, null );\n\n\t\t\tif ( computedStyle ) {\n\t\t\t\tret = computedStyle.getPropertyValue( name );\n\t\t\t}\n\n\t\t\t// We should always get a number back from opacity\n\t\t\tif ( name === \"opacity\" && ret === \"\" ) {\n\t\t\t\tret = \"1\";\n\t\t\t}\n\n\t\t} else if ( elem.currentStyle ) {\n\t\t\tvar camelCase = name.replace(rdashAlpha, fcamelCase);\n\n\t\t\tret = elem.currentStyle[ name ] || elem.currentStyle[ camelCase ];\n\n\t\t\t// From the awesome hack by Dean Edwards\n\t\t\t// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n\n\t\t\t// If we're not dealing with a regular pixel number\n\t\t\t// but a number that has a weird ending, we need to convert it to pixels\n\t\t\tif ( !rnumpx.test( ret ) && rnum.test( ret ) ) {\n\t\t\t\t// Remember the original values\n\t\t\t\tvar left = style.left, rsLeft = elem.runtimeStyle.left;\n\n\t\t\t\t// Put in the new values to get a computed value out\n\t\t\t\telem.runtimeStyle.left = elem.currentStyle.left;\n\t\t\t\tstyle.left = camelCase === \"fontSize\" ? \"1em\" : (ret || 0);\n\t\t\t\tret = style.pixelLeft + \"px\";\n\n\t\t\t\t// Revert the changed values\n\t\t\t\tstyle.left = left;\n\t\t\t\telem.runtimeStyle.left = rsLeft;\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}","jQuery.data":"function ( elem, name, data ) {\n\t\tif ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {\n\t\t\treturn;\n\t\t}\n\n\t\telem = elem == window ?\n\t\t\twindowData :\n\t\t\telem;\n\n\t\tvar id = elem[ expando ], cache = jQuery.cache, thisCache;\n\n\t\t// Handle the case where there's no name immediately\n\t\tif ( !name && !id ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Compute a unique ID for the element\n\t\tif ( !id ) { \n\t\t\tid = ++uuid;\n\t\t}\n\n\t\t// Avoid generating a new cache unless none exists and we\n\t\t// want to manipulate it.\n\t\tif ( typeof name === \"object\" ) {\n\t\t\telem[ expando ] = id;\n\t\t\tthisCache = cache[ id ] = jQuery.extend(true, {}, name);\n\t\t} else if ( cache[ id ] ) {\n\t\t\tthisCache = cache[ id ];\n\t\t} else if ( typeof data === \"undefined\" ) {\n\t\t\tthisCache = emptyObject;\n\t\t} else {\n\t\t\tthisCache = cache[ id ] = {};\n\t\t}\n\n\t\t// Prevent overriding the named cache with undefined values\n\t\tif ( data !== undefined ) {\n\t\t\telem[ expando ] = id;\n\t\t\tthisCache[ name ] = data;\n\t\t}\n\n\t\treturn typeof name === \"string\" ? thisCache[ name ] : thisCache;\n\t}","jQuery.dequeue":"function ( elem, type ){\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ), fn = queue.shift();\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) { fn = queue.shift(); }\n\n\t\tif ( fn ) {\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type == \"fx\" ) { queue.unshift(\"inprogress\"); }\n\n\t\t\tfn.call(elem, function() { jQuery.dequeue(elem, type); });\n\t\t}\n\t}","jQuery.dir":"function ( elem, dir, until ) {\n\t\tvar matched = [], cur = elem[dir];\n\t\twhile ( cur && cur.nodeType !== 9 && (until === undefined || !jQuery( cur ).is( until )) ) {\n\t\t\tif ( cur.nodeType === 1 ) {\n\t\t\t\tmatched.push( cur );\n\t\t\t}\n\t\t\tcur = cur[dir];\n\t\t}\n\t\treturn matched;\n\t}","jQuery.each":"function ( object, callback, args ) {\n\t\tvar name, i = 0,\n\t\t\tlength = object.length,\n\t\t\tisObj = length === undefined || jQuery.isFunction(object);\n\n\t\tif ( args ) {\n\t\t\tif ( isObj ) {\n\t\t\t\tfor ( name in object ) {\n\t\t\t\t\tif ( callback.apply( object[ name ], args ) === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( ; i < length; ) {\n\t\t\t\t\tif ( callback.apply( object[ i++ ], args ) === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// A special, fast, case for the most common use of each\n\t\t} else {\n\t\t\tif ( isObj ) {\n\t\t\t\tfor ( name in object ) {\n\t\t\t\t\tif ( callback.call( object[ name ], name, object[ name ] ) === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( var value = object[0];\n\t\t\t\t\ti < length && callback.call( value, i, value ) !== false; value = object[++i] ) {}\n\t\t\t}\n\t\t}\n\n\t\treturn object;\n\t}","jQuery.Event":"function ( src ){\n\t// Allow instantiation without the 'new' keyword\n\tif ( !this.preventDefault ) {\n\t\treturn new jQuery.Event( src );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// timeStamp is buggy for some events on Firefox(#3843)\n\t// So we won't rely on the native value\n\tthis.timeStamp = now();\n\n\t// Mark it as fixed\n\tthis[ expando ] = true;\n}","jQuery.expando":"\"jQuery1438995819851\"","jQuery.extend":"function () {\n\t// copy reference to target object\n\tvar target = arguments[0] || {}, i = 1, length = arguments.length, deep = false, options, name, src, copy;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\t\ttarget = {};\n\t}\n\n\t// extend jQuery itself if only one argument is passed\n\tif ( length === i ) {\n\t\ttarget = this;\n\t\t--i;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging object literal values\n\t\t\t\tif ( deep && copy && jQuery.isPlainObject(copy) ) {\n\t\t\t\t\t// Don't extend not object literals\n\t\t\t\t\tvar clone = src && jQuery.isPlainObject(src) ? src : {};\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n}","jQuery.filter":"function ( expr, elems, not ) {\n\t\tif ( not ) {\n\t\t\texpr = \":not(\" + expr + \")\";\n\t\t}\n\n\t\treturn jQuery.find.matches(expr, elems);\n\t}","jQuery.find":"function (query, context, extra, seed){\n\t\t\tcontext = context || document;\n\n\t\t\t// Only use querySelectorAll on non-XML documents\n\t\t\t// (ID selectors don't work in non-HTML documents)\n\t\t\tif ( !seed && context.nodeType === 9 && !isXML(context) ) {\n\t\t\t\ttry {\n\t\t\t\t\treturn makeArray( context.querySelectorAll(query), extra );\n\t\t\t\t} catch(e){}\n\t\t\t}\n\t\t\n\t\t\treturn oldSizzle(query, context, extra, seed);\n\t\t}","jQuery.fx":"function ( elem, options, prop ) {\n\t\tthis.options = options;\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\n\t\tif ( !options.orig ) {\n\t\t\toptions.orig = {};\n\t\t}\n\t}","jQuery.get":"function ( url, data, callback, type ) {\n\t\t// shift arguments if data argument was omited\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = null;\n\t\t}\n\n\t\treturn jQuery.ajax({\n\t\t\ttype: \"GET\",\n\t\t\turl: url,\n\t\t\tdata: data,\n\t\t\tsuccess: callback,\n\t\t\tdataType: type\n\t\t});\n\t}","jQuery.getJSON":"function ( url, data, callback ) {\n\t\treturn jQuery.get(url, data, callback, \"json\");\n\t}","jQuery.getScript":"function ( url, callback ) {\n\t\treturn jQuery.get(url, null, callback, \"script\");\n\t}","jQuery.getText":"function getText( elems ) {\n\tvar ret = \"\", elem;\n\n\tfor ( var i = 0; elems[i]; i++ ) {\n\t\telem = elems[i];\n\n\t\t// Get the text from text nodes and CDATA nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 4 ) {\n\t\t\tret += elem.nodeValue;\n\n\t\t// Traverse everything else, except comment nodes\n\t\t} else if ( elem.nodeType !== 8 ) {\n\t\t\tret += getText( elem.childNodes );\n\t\t}\n\t}\n\n\treturn ret;\n}","jQuery.globalEval":"function ( data ) {\n\t\tif ( data && rnotwhite.test(data) ) {\n\t\t\t// Inspired by code by Andrea Giammarchi\n\t\t\t// http://webreflection.blogspot.com/2007/08/global-scope-evaluation-and-dom.html\n\t\t\tvar head = document.getElementsByTagName(\"head\")[0] || document.documentElement,\n\t\t\t\tscript = document.createElement(\"script\");\n\n\t\t\tscript.type = \"text/javascript\";\n\n\t\t\tif ( jQuery.support.scriptEval ) {\n\t\t\t\tscript.appendChild( document.createTextNode( data ) );\n\t\t\t} else {\n\t\t\t\tscript.text = data;\n\t\t\t}\n\n\t\t\t// Use insertBefore instead of appendChild to circumvent an IE6 bug.\n\t\t\t// This arises when a base node is used (#2709).\n\t\t\thead.insertBefore( script, head.firstChild );\n\t\t\thead.removeChild( script );\n\t\t}\n\t}","jQuery.grep":"function ( elems, callback, inv ) {\n\t\tvar ret = [];\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( var i = 0, length = elems.length; i < length; i++ ) {\n\t\t\tif ( !inv !== !callback( elems[ i ], i ) ) {\n\t\t\t\tret.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}","jQuery.handleError":"function ( s, xhr, status, e ) {\n\t\t// If a local callback was specified, fire it\n\t\tif ( s.error ) {\n\t\t\ts.error.call( s.context || window, xhr, status, e );\n\t\t}\n\n\t\t// Fire the global callback\n\t\tif ( s.global ) {\n\t\t\t(s.context ? jQuery(s.context) : jQuery.event).trigger( \"ajaxError\", [xhr, s, e] );\n\t\t}\n\t}","jQuery.httpData":"function ( xhr, type, s ) {\n\t\tvar ct = xhr.getResponseHeader(\"content-type\"),\n\t\t\txml = type === \"xml\" || !type && ct && ct.indexOf(\"xml\") >= 0,\n\t\t\tdata = xml ? xhr.responseXML : xhr.responseText;\n\n\t\tif ( xml && data.documentElement.nodeName === \"parsererror\" ) {\n\t\t\tthrow \"parsererror\";\n\t\t}\n\n\t\t// Allow a pre-filtering function to sanitize the response\n\t\t// s is checked to keep backwards compatibility\n\t\tif ( s && s.dataFilter ) {\n\t\t\tdata = s.dataFilter( data, type );\n\t\t}\n\n\t\t// The filter can actually parse the response\n\t\tif ( typeof data === \"string\" ) {\n\n\t\t\t// If the type is \"script\", eval it in global context\n\t\t\tif ( type === \"script\" ) {\n\t\t\t\tjQuery.globalEval( data );\n\t\t\t}\n\n\t\t\t// Get the JavaScript object, if JSON is used.\n\t\t\tif ( type === \"json\" ) {\n\t\t\t\tif ( typeof JSON === \"object\" && JSON.parse ) {\n\t\t\t\t\tdata = JSON.parse( data );\n\t\t\t\t} else {\n\t\t\t\t\tdata = (new Function(\"return \" + data))();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn data;\n\t}","jQuery.httpNotModified":"function ( xhr, url ) {\n\t\tvar lastModified = xhr.getResponseHeader(\"Last-Modified\"),\n\t\t\tetag = xhr.getResponseHeader(\"Etag\");\n\n\t\tif ( lastModified ) {\n\t\t\tjQuery.lastModified[url] = lastModified;\n\t\t}\n\n\t\tif ( etag ) {\n\t\t\tjQuery.etag[url] = etag;\n\t\t}\n\n\t\t// Opera returns 0 when status is 304\n\t\treturn xhr.status === 304 || xhr.status === 0;\n\t}","jQuery.httpSuccess":"function ( xhr ) {\n\t\ttry {\n\t\t\t// IE error sometimes returns 1223 when it should be 204 so treat it as success, see #1450\n\t\t\treturn !xhr.status && location.protocol === \"file:\" ||\n\t\t\t\t// Opera returns 0 when status is 304\n\t\t\t\t( xhr.status >= 200 && xhr.status < 300 ) ||\n\t\t\t\txhr.status === 304 || xhr.status === 1223 || xhr.status === 0;\n\t\t} catch(e){}\n\n\t\treturn false;\n\t}","jQuery.inArray":"function ( elem, array ) {\n\t\treturn indexOf.call( array, elem );\n\t}","jQuery.isArray":"function ( obj ) {\n\t\treturn toString.call(obj) === \"[object Array]\";\n\t}","jQuery.isEmptyObject":"function ( obj ) {\n\t\tfor ( var name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}","jQuery.isFunction":"function ( obj ) {\n\t\treturn toString.call(obj) === \"[object Function]\";\n\t}","jQuery.isPlainObject":"function ( obj ) {\n\t\t// Must be an Object.\n\t\t// Because of IE, we also have to check the presence of the constructor property.\n\t\t// Make sure that DOM nodes and window objects don't pass through, as well\n\t\tif ( !obj || toString.call(obj) !== \"[object Object]\" || obj.nodeType || obj.setInterval ) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t// Not own constructor property must be Object\n\t\tif ( obj.constructor\n\t\t\t&& !hasOwnProperty.call(obj, \"constructor\")\n\t\t\t&& !hasOwnProperty.call(obj.constructor.prototype, \"isPrototypeOf\") ) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t// Own properties are enumerated firstly, so to speed up,\n\t\t// if last one is own, then all properties are own.\n\t\n\t\tvar key;\n\t\tfor ( key in obj ) {}\n\t\t\n\t\treturn key === undefined || hasOwnProperty.call( obj, key );\n\t}","jQuery.isReady":"true","jQuery.isXMLDoc":"function (elem){\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833) \n\tvar documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n}","jQuery.makeArray":"function ( array, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( array != null ) {\n\t\t\t// The window, strings (and functions) also have 'length'\n\t\t\t// The extra typeof function check is to prevent crashes\n\t\t\t// in Safari 2 (See: #3039)\n\t\t\tif ( array.length == null || typeof array === \"string\" || jQuery.isFunction(array) || (typeof array !== \"function\" && array.setInterval) ) {\n\t\t\t\tpush.call( ret, array );\n\t\t\t} else {\n\t\t\t\tjQuery.merge( ret, array );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}","jQuery.map":"function ( elems, callback, arg ) {\n\t\tvar ret = [], value;\n\n\t\t// Go through the array, translating each of the items to their\n\t\t// new value (or values).\n\t\tfor ( var i = 0, length = elems.length; i < length; i++ ) {\n\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\tif ( value != null ) {\n\t\t\t\tret[ ret.length ] = value;\n\t\t\t}\n\t\t}\n\n\t\treturn ret.concat.apply( [], ret );\n\t}","jQuery.merge":"function ( first, second ) {\n\t\tvar i = first.length, j = 0;\n\n\t\tif ( typeof second.length === \"number\" ) {\n\t\t\tfor ( var l = second.length; j < l; j++ ) {\n\t\t\t\tfirst[ i++ ] = second[ j ];\n\t\t\t}\n\t\t} else {\n\t\t\twhile ( second[j] !== undefined ) {\n\t\t\t\tfirst[ i++ ] = second[ j++ ];\n\t\t\t}\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t}","jQuery.noConflict":"function ( deep ) {\n\t\twindow.$ = _$;\n\n\t\tif ( deep ) {\n\t\t\twindow.jQuery = _jQuery;\n\t\t}\n\n\t\treturn jQuery;\n\t}","jQuery.nodeName":"function ( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();\n\t}","jQuery.nth":"function ( cur, result, dir, elem ) {\n\t\tresult = result || 1;\n\t\tvar num = 0;\n\n\t\tfor ( ; cur; cur = cur[dir] ) {\n\t\t\tif ( cur.nodeType === 1 && ++num === result ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn cur;\n\t}","jQuery.param":"function ( a ) {\n\t\t\n\t\tvar s = [],\n\t\t\t\n\t\t\t// Set jQuery.param.traditional to true for jQuery <= 1.3.2 behavior.\n\t\t\ttraditional = jQuery.param.traditional;\n\t\t\n\t\tfunction add( key, value ){\n\t\t\t// If value is a function, invoke it and return its value\n\t\t\tvalue = jQuery.isFunction(value) ? value() : value;\n\t\t\ts[ s.length ] = encodeURIComponent(key) + '=' + encodeURIComponent(value);\n\t\t}\n\t\t\n\t\t// If an array was passed in, assume that it is an array of form elements.\n\t\tif ( jQuery.isArray(a) || a.jquery ) {\n\t\t\t// Serialize the form elements\n\t\t\tjQuery.each( a, function() {\n\t\t\t\tadd( this.name, this.value );\n\t\t\t});\n\t\t\t\n\t\t} else {\n\t\t\t// If jQuery.param.traditional is true, encode the \"old\" way (the\n\t\t\t// way 1.3.2 or older did it), otherwise encode params recursively.\n\t\t\tjQuery.each( a, function buildParams( prefix, obj ) {\n\t\t\t\t\n\t\t\t\tif ( jQuery.isArray(obj) ) {\n\t\t\t\t\t// Serialize array item.\n\t\t\t\t\tjQuery.each( obj, function(i,v){\n\t\t\t\t\t\tif ( traditional ) {\n\t\t\t\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\t\t\t\tadd( prefix, v );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// If array item is non-scalar (array or object), encode its\n\t\t\t\t\t\t\t// numeric index to resolve deserialization ambiguity issues.\n\t\t\t\t\t\t\t// Note that rack (as of 1.0.0) can't currently deserialize\n\t\t\t\t\t\t\t// nested arrays properly, and attempting to do so may cause\n\t\t\t\t\t\t\t// a server error. Possible fixes are to modify rack's\n\t\t\t\t\t\t\t// deserialization algorithm or to provide an option or flag\n\t\t\t\t\t\t\t// to force array serialization to be shallow.\n\t\t\t\t\t\t\tbuildParams( prefix + \"[\" + ( typeof v === \"object\" || jQuery.isArray(v) ? i : \"\" ) + \"]\", v );\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t} else if ( !traditional && typeof obj === \"object\" ) {\n\t\t\t\t\t// Serialize object item.\n\t\t\t\t\tjQuery.each( obj, function(k,v){\n\t\t\t\t\t\tbuildParams( prefix + \"[\" + k + \"]\", v );\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t// Serialize scalar item.\n\t\t\t\t\tadd( prefix, obj );\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\t// Return the resulting serialization\n\t\treturn s.join(\"&\").replace(r20, \"+\");\n\t}","jQuery.post":"function ( url, data, callback, type ) {\n\t\t// shift arguments if data argument was omited\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = {};\n\t\t}\n\n\t\treturn jQuery.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: url,\n\t\t\tdata: data,\n\t\t\tsuccess: callback,\n\t\t\tdataType: type\n\t\t});\n\t}","jQuery.queue":"function ( elem, type, data ) {\n\t\tif ( !elem ) { return; }\n\n\t\ttype = (type || \"fx\") + \"queue\";\n\t\tvar q = jQuery.data( elem, type );\n\n\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\tif ( !data ) { return q || []; }\n\n\t\tif ( !q || jQuery.isArray(data) ) {\n\t\t\tq = jQuery.data( elem, type, jQuery.makeArray(data) );\n\t\t} else {\n\t\t\tq.push( data );\n\t\t}\n\t\treturn q;\n\t}","jQuery.ready":"function () {\n\t\t// Make sure that the DOM is not already loaded\n\t\tif ( !jQuery.isReady ) {\n\t\t\t// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n\t\t\tif ( !document.body ) {\n\t\t\t\treturn setTimeout( jQuery.ready, 13 );\n\t\t\t}\n\n\t\t\t// Remember that the DOM is ready\n\t\t\tjQuery.isReady = true;\n\n\t\t\t// If there are functions bound, to execute\n\t\t\tif ( readyList ) {\n\t\t\t\t// Execute all of them\n\t\t\t\tvar fn, i = 0;\n\t\t\t\twhile ( (fn = readyList[ i++ ]) ) {\n\t\t\t\t\tfn.call( document, jQuery );\n\t\t\t\t}\n\n\t\t\t\t// Reset the list of functions\n\t\t\t\treadyList = null;\n\t\t\t}\n\n\t\t\t// Trigger any bound ready events\n\t\t\tif ( jQuery.fn.triggerHandler ) {\n\t\t\t\tjQuery( document ).triggerHandler( \"ready\" );\n\t\t\t}\n\t\t}\n\t}","jQuery.removeData":"function ( elem, name ) {\n\t\tif ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {\n\t\t\treturn;\n\t\t}\n\n\t\telem = elem == window ?\n\t\t\twindowData :\n\t\t\telem;\n\n\t\tvar id = elem[ expando ], cache = jQuery.cache, thisCache = cache[ id ];\n\n\t\t// If we want to remove a specific section of the element's data\n\t\tif ( name ) {\n\t\t\tif ( thisCache ) {\n\t\t\t\t// Remove the section of cache data\n\t\t\t\tdelete thisCache[ name ];\n\n\t\t\t\t// If we've removed all the data, remove the element's cache\n\t\t\t\tif ( jQuery.isEmptyObject(thisCache) ) {\n\t\t\t\t\tjQuery.removeData( elem );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Otherwise, we want to remove all of the element's data\n\t\t} else {\n\t\t\t// Clean up the element expando\n\t\t\ttry {\n\t\t\t\tdelete elem[ expando ];\n\t\t\t} catch( e ) {\n\t\t\t\t// IE has trouble directly removing the expando\n\t\t\t\t// but it's ok with using removeAttribute\n\t\t\t\tif ( elem.removeAttribute ) {\n\t\t\t\t\telem.removeAttribute( expando );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Completely remove the data cache\n\t\t\tdelete cache[ id ];\n\t\t}\n\t}","jQuery.sibling":"function ( n, elem ) {\n\t\tvar r = [];\n\n\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\tr.push( n );\n\t\t\t}\n\t\t}\n\n\t\treturn r;\n\t}","jQuery.speed":"function ( speed, easing, fn ) {\n\t\tvar opt = speed && typeof speed === \"object\" ? speed : {\n\t\t\tcomplete: fn || !fn && easing ||\n\t\t\t\tjQuery.isFunction( speed ) && speed,\n\t\t\tduration: speed,\n\t\t\teasing: fn && easing || easing && !jQuery.isFunction(easing) && easing\n\t\t};\n\n\t\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n\t\t\tjQuery.fx.speeds[opt.duration] || jQuery.fx.speeds._default;\n\n\t\t// Queueing\n\t\topt.old = opt.complete;\n\t\topt.complete = function(){\n\t\t\tif ( opt.queue !== false ) {\n\t\t\t\tjQuery(this).dequeue();\n\t\t\t}\n\t\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\t\topt.old.call( this );\n\t\t\t}\n\t\t};\n\n\t\treturn opt;\n\t}","jQuery.style":"function ( elem, name, value ) {\n\t\t// don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// ignore negative width and height values #1599\n\t\tif ( (name === \"width\" || name === \"height\") && parseFloat(value) < 0 ) {\n\t\t\tvalue = undefined;\n\t\t}\n\n\t\tvar style = elem.style || elem, set = value !== undefined;\n\n\t\t// IE uses filters for opacity\n\t\tif ( !jQuery.support.opacity && name === \"opacity\" ) {\n\t\t\tif ( set ) {\n\t\t\t\t// IE has trouble with opacity if it does not have layout\n\t\t\t\t// Force it by setting the zoom level\n\t\t\t\tstyle.zoom = 1;\n\n\t\t\t\t// Set the alpha filter to set the opacity\n\t\t\t\tvar opacity = parseInt( value, 10 ) + '' === \"NaN\" ? \"\" : \"alpha(opacity=\" + value * 100 + \")\";\n\t\t\t\tvar filter = style.filter || jQuery.curCSS( elem, 'filter' ) || \"\";\n\t\t\t\tstyle.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : opacity;\n\t\t\t}\n\n\t\t\treturn style.filter && style.filter.indexOf(\"opacity=\") >= 0 ?\n\t\t\t\t(parseFloat( ropacity.exec(style.filter)[1] ) / 100) + '':\n\t\t\t\t\"\";\n\t\t}\n\n\t\t// Make sure we're using the right name for getting the float value\n\t\tif ( rfloat.test( name ) ) {\n\t\t\tname = styleFloat;\n\t\t}\n\n\t\tname = name.replace(rdashAlpha, fcamelCase);\n\n\t\tif ( set ) {\n\t\t\tstyle[ name ] = value;\n\t\t}\n\n\t\treturn style[ name ];\n\t}","jQuery.swap":"function ( elem, options, callback ) {\n\t\tvar old = {};\n\n\t\t// Remember the old values, and insert the new ones\n\t\tfor ( var name in options ) {\n\t\t\told[ name ] = elem.style[ name ];\n\t\t\telem.style[ name ] = options[ name ];\n\t\t}\n\n\t\tcallback.call( elem );\n\n\t\t// Revert the old values\n\t\tfor ( var name in options ) {\n\t\t\telem.style[ name ] = old[ name ];\n\t\t}\n\t}","jQuery.trim":"function ( text ) {\n\t\treturn (text || \"\").replace( rtrim, \"\" );\n\t}","jQuery.unique":"function (results){\n\tif ( sortOrder ) {\n\t\thasDuplicate = baseHasDuplicate;\n\t\tresults.sort(sortOrder);\n\n\t\tif ( hasDuplicate ) {\n\t\t\tfor ( var i = 1; i < results.length; i++ ) {\n\t\t\t\tif ( results[i] === results[i-1] ) {\n\t\t\t\t\tresults.splice(i--, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn results;\n}","jQuery.ajaxSettings.async":"true","jQuery.ajaxSettings.contentType":"\"application/x-www-form-urlencoded\"","jQuery.ajaxSettings.global":"true","jQuery.ajaxSettings.processData":"true","jQuery.ajaxSettings.type":"\"GET\"","jQuery.ajaxSettings.url":"\"http://localhost:8080/jQueryExplorerServlet/f34.html\"","jQuery.ajaxSettings.xhr":"function (){\n\t\t\treturn window.ActiveXObject ?\n\t\t\t\tnew ActiveXObject(\"Microsoft.XMLHTTP\") :\n\t\t\t\tnew XMLHttpRequest();\n\t\t}","jQuery.attrFn.css":"true","jQuery.attrFn.data":"true","jQuery.attrFn.height":"true","jQuery.attrFn.html":"true","jQuery.attrFn.offset":"true","jQuery.attrFn.text":"true","jQuery.attrFn.val":"true","jQuery.attrFn.width":"true","jQuery.browser.firefox":"false","jQuery.browser.mozilla":"false","jQuery.browser.msie":"false","jQuery.browser.opera":"false","jQuery.browser.safari":"true","jQuery.browser.version":"\"537.36\"","jQuery.easing.linear":"function ( p, n, firstNum, diff ) {\n\t\t\treturn firstNum + diff * p;\n\t\t}","jQuery.easing.swing":"function ( p, n, firstNum, diff ) {\n\t\t\treturn ((-Math.cos(p*Math.PI)/2) + 0.5) * diff + firstNum;\n\t\t}","jQuery.event.add":"function ( elem, types, handler, data ) {\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// For whatever reason, IE has trouble passing the window object\n\t\t// around, causing it to be cloned in the process\n\t\tif ( elem.setInterval && ( elem !== window && !elem.frameElement ) ) {\n\t\t\telem = window;\n\t\t}\n\n\t\t// Make sure that the function being executed has a unique ID\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = this.guid++;\n\t\t}\n\n\t\t// if data is passed, bind to handler\n\t\tif ( data !== undefined ) {\n\t\t\t// Create temporary function pointer to original handler\n\t\t\tvar fn = handler;\n\n\t\t\t// Create unique handler function, wrapped around original handler\n\t\t\thandler = this.proxy( fn );\n\n\t\t\t// Store data in unique handler\n\t\t\thandler.data = data;\n\t\t}\n\n\t\t// Init the element's event structure\n\t\tvar events = jQuery.data( elem, \"events\" ) || jQuery.data( elem, \"events\", {} ),\n\t\t\thandle = jQuery.data( elem, \"handle\" ), eventHandle;\n\n\t\tif ( !handle ) {\n\t\t\teventHandle = function() {\n\t\t\t\t// Handle the second event of a trigger and when\n\t\t\t\t// an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && !jQuery.event.triggered ?\n\t\t\t\t\tjQuery.event.handle.apply( eventHandle.elem, arguments ) :\n\t\t\t\t\tundefined;\n\t\t\t};\n\n\t\t\thandle = jQuery.data( elem, \"handle\", eventHandle );\n\t\t}\n\n\t\t// Add elem as a property of the handle function\n\t\t// This is to prevent a memory leak with non-native\n\t\t// event in IE.\n\t\thandle.elem = elem;\n\n\t\t// Handle multiple events separated by a space\n\t\t// jQuery(...).bind(\"mouseover mouseout\", fn);\n\t\ttypes = types.split( /\\s+/ );\n\t\tvar type, i=0;\n\t\twhile ( (type = types[ i++ ]) ) {\n\t\t\t// Namespaced event handlers\n\t\t\tvar namespaces = type.split(\".\");\n\t\t\ttype = namespaces.shift();\n\t\t\thandler.type = namespaces.slice(0).sort().join(\".\");\n\n\t\t\t// Get the current list of functions bound to this event\n\t\t\tvar handlers = events[ type ],\n\t\t\t\tspecial = this.special[ type ] || {};\n\n\t\t\t\n\n\t\t\t// Init the event handler queue\n\t\t\tif ( !handlers ) {\n\t\t\t\thandlers = events[ type ] = {};\n\n\t\t\t\t// Check for a special event handler\n\t\t\t\t// Only use addEventListener/attachEvent if the special\n\t\t\t\t// events handler returns false\n\t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, handler) === false ) {\n\t\t\t\t\t// Bind the global event handler to the element\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, handle, false );\n\t\t\t\t\t} else if ( elem.attachEvent ) {\n\t\t\t\t\t\telem.attachEvent( \"on\" + type, handle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif ( special.add ) { \n\t\t\t\tvar modifiedHandler = special.add.call( elem, handler, data, namespaces, handlers ); \n\t\t\t\tif ( modifiedHandler && jQuery.isFunction( modifiedHandler ) ) { \n\t\t\t\t\tmodifiedHandler.guid = modifiedHandler.guid || handler.guid; \n\t\t\t\t\thandler = modifiedHandler; \n\t\t\t\t} \n\t\t\t} \n\t\t\t\n\t\t\t// Add the function to the element's handler list\n\t\t\thandlers[ handler.guid ] = handler;\n\n\t\t\t// Keep track of which events have been used, for global triggering\n\t\t\tthis.global[ type ] = true;\n\t\t}\n\n\t\t// Nullify elem to prevent memory leaks in IE\n\t\telem = null;\n\t}","jQuery.event.fix":"function ( event ) {\n\t\tif ( event[ expando ] ) {\n\t\t\treturn event;\n\t\t}\n\n\t\t// store a copy of the original event object\n\t\t// and \"clone\" to set read-only properties\n\t\tvar originalEvent = event;\n\t\tevent = jQuery.Event( originalEvent );\n\n\t\tfor ( var i = this.props.length, prop; i; ) {\n\t\t\tprop = this.props[ --i ];\n\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t}\n\n\t\t// Fix target property, if necessary\n\t\tif ( !event.target ) {\n\t\t\tevent.target = event.srcElement || document; // Fixes #1925 where srcElement might not be defined either\n\t\t}\n\n\t\t// check if target is a textnode (safari)\n\t\tif ( event.target.nodeType === 3 ) {\n\t\t\tevent.target = event.target.parentNode;\n\t\t}\n\n\t\t// Add relatedTarget, if necessary\n\t\tif ( !event.relatedTarget && event.fromElement ) {\n\t\t\tevent.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;\n\t\t}\n\n\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\tif ( event.pageX == null && event.clientX != null ) {\n\t\t\tvar doc = document.documentElement, body = document.body;\n\t\t\tevent.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n\t\t\tevent.pageY = event.clientY + (doc && doc.scrollTop  || body && body.scrollTop  || 0) - (doc && doc.clientTop  || body && body.clientTop  || 0);\n\t\t}\n\n\t\t// Add which for key events\n\t\tif ( !event.which && ((event.charCode || event.charCode === 0) ? event.charCode : event.keyCode) ) {\n\t\t\tevent.which = event.charCode || event.keyCode;\n\t\t}\n\n\t\t// Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)\n\t\tif ( !event.metaKey && event.ctrlKey ) {\n\t\t\tevent.metaKey = event.ctrlKey;\n\t\t}\n\n\t\t// Add which for click: 1 == left; 2 == middle; 3 == right\n\t\t// Note: button is not normalized, so don't use it\n\t\tif ( !event.which && event.button !== undefined ) {\n\t\t\tevent.which = (event.button & 1 ? 1 : ( event.button & 2 ? 3 : ( event.button & 4 ? 2 : 0 ) ));\n\t\t}\n\n\t\treturn event;\n\t}","jQuery.event.guid":"1","jQuery.event.handle":"function ( event ) {\n\t\t// returned undefined or false\n\t\tvar all, handlers;\n\n\t\tevent = arguments[0] = jQuery.event.fix( event || window.event );\n\t\tevent.currentTarget = this;\n\n\t\t// Namespaced event handlers\n\t\tvar namespaces = event.type.split(\".\");\n\t\tevent.type = namespaces.shift();\n\n\t\t// Cache this now, all = true means, any handler\n\t\tall = !namespaces.length && !event.exclusive;\n\n\t\tvar namespace = new RegExp(\"(^|\\\\.)\" + namespaces.slice(0).sort().join(\"\\\\.(?:.*\\\\.)?\") + \"(\\\\.|$)\");\n\n\t\thandlers = ( jQuery.data(this, \"events\") || {} )[ event.type ];\n\n\t\tfor ( var j in handlers ) {\n\t\t\tvar handler = handlers[ j ];\n\n\t\t\t// Filter the functions by class\n\t\t\tif ( all || namespace.test(handler.type) ) {\n\t\t\t\t// Pass in a reference to the handler function itself\n\t\t\t\t// So that we can later remove it\n\t\t\t\tevent.handler = handler;\n\t\t\t\tevent.data = handler.data;\n\n\t\t\t\tvar ret = handler.apply( this, arguments );\n\n\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\tevent.result = ret;\n\t\t\t\t\tif ( ret === false ) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( event.isImmediatePropagationStopped() ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t}","jQuery.event.proxy":"function ( fn, proxy, thisObject ) {\n\t\tif ( proxy !== undefined && !jQuery.isFunction( proxy ) ) {\n\t\t\tthisObject = proxy;\n\t\t\tproxy = undefined;\n\t\t}\n\t\t// FIXME: Should proxy be redefined to be applied with thisObject if defined?\n\t\tproxy = proxy || function() { return fn.apply( thisObject !== undefined ? thisObject : this, arguments ); };\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || proxy.guid || this.guid++;\n\t\t// So proxy can be declared as an argument\n\t\treturn proxy;\n\t}","jQuery.event.remove":"function ( elem, types, handler ) {\n\t\t// don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar events = jQuery.data( elem, \"events\" ), ret, type, fn;\n\n\t\tif ( events ) {\n\t\t\t// Unbind all events for the element\n\t\t\tif ( types === undefined || (typeof types === \"string\" && types.charAt(0) === \".\") ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tthis.remove( elem, type + (types || \"\") );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// types is actually an event object here\n\t\t\t\tif ( types.type ) {\n\t\t\t\t\thandler = types.handler;\n\t\t\t\t\ttypes = types.type;\n\t\t\t\t}\n\n\t\t\t\t// Handle multiple events separated by a space\n\t\t\t\t// jQuery(...).unbind(\"mouseover mouseout\", fn);\n\t\t\t\ttypes = types.split(/\\s+/);\n\t\t\t\tvar i = 0;\n\t\t\t\twhile ( (type = types[ i++ ]) ) {\n\t\t\t\t\t// Namespaced event handlers\n\t\t\t\t\tvar namespaces = type.split(\".\");\n\t\t\t\t\ttype = namespaces.shift();\n\t\t\t\t\tvar all = !namespaces.length,\n\t\t\t\t\t\tcleaned = jQuery.map( namespaces.slice(0).sort() , function(nm){ return nm.replace(/[^\\w\\s\\.\\|`]/g, function(ch){return \"\\\\\"+ch;  }); }),\n\t\t\t\t\t\tnamespace = new RegExp(\"(^|\\\\.)\" + cleaned.join(\"\\\\.(?:.*\\\\.)?\") + \"(\\\\.|$)\"),\n\t\t\t\t\t\tspecial = this.special[ type ] || {};\n\n\t\t\t\t\tif ( events[ type ] ) {\n\t\t\t\t\t\t// remove the given handler for the given type\n\t\t\t\t\t\tif ( handler ) {\n\t\t\t\t\t\t\tfn = events[ type ][ handler.guid ];\n\t\t\t\t\t\t\tdelete events[ type ][ handler.guid ];\n\n\t\t\t\t\t\t// remove all handlers for the given type\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor ( var handle in events[ type ] ) {\n\t\t\t\t\t\t\t\t// Handle the removal of namespaced events\n\t\t\t\t\t\t\t\tif ( all || namespace.test( events[ type ][ handle ].type ) ) {\n\t\t\t\t\t\t\t\t\tdelete events[ type ][ handle ];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\t\tspecial.remove.call( elem, namespaces, fn);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// remove generic event handler if no more handlers exist\n\t\t\t\t\t\tfor ( ret in events[ type ] ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( !ret ) {\n\t\t\t\t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {\n\t\t\t\t\t\t\t\tif ( elem.removeEventListener ) {\n\t\t\t\t\t\t\t\t\telem.removeEventListener( type, jQuery.data( elem, \"handle\" ), false );\n\t\t\t\t\t\t\t\t} else if ( elem.detachEvent ) {\n\t\t\t\t\t\t\t\t\telem.detachEvent( \"on\" + type, jQuery.data( elem, \"handle\" ) );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tret = null;\n\t\t\t\t\t\t\tdelete events[ type ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove the expando if it's no longer used\n\t\t\tfor ( ret in events ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !ret ) {\n\t\t\t\tvar handle = jQuery.data( elem, \"handle\" );\n\t\t\t\tif ( handle ) {\n\t\t\t\t\thandle.elem = null;\n\t\t\t\t}\n\t\t\t\tjQuery.removeData( elem, \"events\" );\n\t\t\t\tjQuery.removeData( elem, \"handle\" );\n\t\t\t}\n\t\t}\n\t}","jQuery.event.trigger":"function ( event, data, elem /*, bubbling */ ) {\n\t\t// Event object or event type\n\t\tvar type = event.type || event,\n\t\t\tbubbling = arguments[3];\n\n\t\tif ( !bubbling ) {\n\t\t\tevent = typeof event === \"object\" ?\n\t\t\t\t// jQuery.Event object\n\t\t\t\tevent[expando] ? event :\n\t\t\t\t// Object literal\n\t\t\t\tjQuery.extend( jQuery.Event(type), event ) :\n\t\t\t\t// Just the event type (string)\n\t\t\t\tjQuery.Event(type);\n\n\t\t\tif ( type.indexOf(\"!\") >= 0 ) {\n\t\t\t\tevent.type = type = type.slice(0, -1);\n\t\t\t\tevent.exclusive = true;\n\t\t\t}\n\n\t\t\t// Handle a global trigger\n\t\t\tif ( !elem ) {\n\t\t\t\t// Don't bubble custom events when global (to avoid too much overhead)\n\t\t\t\tevent.stopPropagation();\n\t\t\t\t// Only trigger if we've ever bound an event for it\n\t\t\t\tif ( this.global[ type ] ) {\n\t\t\t\t\tjQuery.each( jQuery.cache, function() {\n\t\t\t\t\t\tif ( this.events && this.events[type] ) {\n\t\t\t\t\t\t\tjQuery.event.trigger( event, data, this.handle.elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Handle triggering a single element\n\n\t\t\t// don't do events on text and comment nodes\n\t\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\t// Clean up in case it is reused\n\t\t\tevent.result = undefined;\n\t\t\tevent.target = elem;\n\n\t\t\t// Clone the incoming data, if any\n\t\t\tdata = jQuery.makeArray( data );\n\t\t\tdata.unshift( event );\n\t\t}\n\n\t\tevent.currentTarget = elem;\n\n\t\t// Trigger the event, it is assumed that \"handle\" is a function\n\t\tvar handle = jQuery.data( elem, \"handle\" );\n\t\tif ( handle ) {\n\t\t\thandle.apply( elem, data );\n\t\t}\n\n\t\tvar nativeFn, nativeHandler;\n\t\ttry {\n\t\t\tif ( !(elem && elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()]) ) {\n\t\t\t\tnativeFn = elem[ type ];\n\t\t\t\tnativeHandler = elem[ \"on\" + type ];\n\t\t\t}\n\t\t// prevent IE from throwing an error for some elements with some event types, see #3533\n\t\t} catch (e) {}\n\n\t\tvar isClick = jQuery.nodeName(elem, \"a\") && type === \"click\";\n\n\t\t// Trigger the native events (except for clicks on links)\n\t\tif ( !bubbling && nativeFn && !event.isDefaultPrevented() && !isClick ) {\n\t\t\tthis.triggered = true;\n\t\t\ttry {\n\t\t\t\telem[ type ]();\n\t\t\t// prevent IE from throwing an error for some hidden elements\n\t\t\t} catch (e) {}\n\n\t\t// Handle triggering native .onfoo handlers\n\t\t} else if ( nativeHandler && elem[ \"on\" + type ].apply( elem, data ) === false ) {\n\t\t\tevent.result = false;\n\t\t}\n\n\t\tthis.triggered = false;\n\n\t\tif ( !event.isPropagationStopped() ) {\n\t\t\tvar parent = elem.parentNode || elem.ownerDocument;\n\t\t\tif ( parent ) {\n\t\t\t\tjQuery.event.trigger( event, data, parent, true );\n\t\t\t}\n\t\t}\n\t}","jQuery.event.triggered":"false","jQuery.fn._load":"function ( fn ) {\n\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t}","jQuery.fn._toggle":"function ( fn ) {\n\t\t// Save reference to arguments for access in closure\n\t\tvar args = arguments, i = 1;\n\n\t\t// link all the functions, so any of them can unbind this click handler\n\t\twhile( i < args.length ) {\n\t\t\tjQuery.event.proxy( fn, args[ i++ ] );\n\t\t}\n\n\t\treturn this.click( jQuery.event.proxy( fn, function( event ) {\n\t\t\t// Figure out which function to execute\n\t\t\tvar lastToggle = ( jQuery.data( this, 'lastToggle' + fn.guid ) || 0 ) % i;\n\t\t\tjQuery.data( this, 'lastToggle' + fn.guid, lastToggle + 1 );\n\n\t\t\t// Make sure that clicks stop\n\t\t\tevent.preventDefault();\n\n\t\t\t// and execute the function\n\t\t\treturn args[ lastToggle ].apply( this, arguments ) || false;\n\t\t}));\n\t}","jQuery.fn.add":"function ( selector, context ) {\n\t\tvar set = typeof selector === \"string\" ?\n\t\t\t\tjQuery( selector, context || this.context ) :\n\t\t\t\tjQuery.makeArray( selector ),\n\t\t\tall = jQuery.merge( this.get(), set );\n\n\t\treturn this.pushStack( set[0] && (set[0].setInterval || set[0].nodeType === 9 || (set[0].parentNode && set[0].parentNode.nodeType !== 11)) ?\n\t\t\tjQuery.unique( all ) :\n\t\t\tall );\n\t}","jQuery.fn.addClass":"function ( value ) {\n\t\tif ( jQuery.isFunction(value) ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery(this).addClass( value.call(this) );\n\t\t\t});\n\t\t}\n\n\t\tif ( value && typeof value === \"string\" ) {\n\t\t\tvar classNames = (value || \"\").split( rspace );\n\n\t\t\tfor ( var i = 0, l = this.length; i < l; i++ ) {\n\t\t\t\tvar elem = this[i];\n\n\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\tif ( !elem.className ) {\n\t\t\t\t\t\telem.className = value;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar className = \" \" + elem.className + \" \";\n\t\t\t\t\t\tfor ( var c = 0, cl = classNames.length; c < cl; c++ ) {\n\t\t\t\t\t\t\tif ( className.indexOf( \" \" + classNames[c] + \" \" ) < 0 ) {\n\t\t\t\t\t\t\t\telem.className += \" \" + classNames[c];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}","jQuery.fn.after":"function () {\n\t\tif ( this[0] && this[0].parentNode ) {\n\t\t\treturn this.domManip(arguments, false, function(elem){\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t});\n\t\t} else if ( arguments.length ) {\n\t\t\tvar set = this.pushStack( this, \"after\", arguments );\n\t\t\tset.push.apply( set, jQuery(arguments[0]).toArray() );\n\t\t\treturn set;\n\t\t}\n\t}","jQuery.fn.ajaxComplete":"function (f){\n\t\treturn this.bind(o, f);\n\t}","jQuery.fn.ajaxError":"function (f){\n\t\treturn this.bind(o, f);\n\t}","jQuery.fn.ajaxSend":"function (f){\n\t\treturn this.bind(o, f);\n\t}","jQuery.fn.ajaxStart":"function (f){\n\t\treturn this.bind(o, f);\n\t}","jQuery.fn.ajaxStop":"function (f){\n\t\treturn this.bind(o, f);\n\t}","jQuery.fn.ajaxSuccess":"function (f){\n\t\treturn this.bind(o, f);\n\t}","jQuery.fn.andSelf":"function () {\n\t\treturn this.add( this.prevObject );\n\t}","jQuery.fn.animate":"function ( prop, speed, easing, callback ) {\n\t\tvar optall = jQuery.speed(speed, easing, callback);\n\n\t\treturn this[ optall.queue === false ? \"each\" : \"queue\" ](function() {\n\t\t\tvar opt = jQuery.extend({}, optall), p,\n\t\t\t\thidden = this.nodeType === 1 && jQuery(this).is(\":hidden\"),\n\t\t\t\tself = this;\n\n\t\t\tfor ( p in prop ) {\n\t\t\t\tvar name = p.replace(rdashAlpha, fcamelCase);\n\n\t\t\t\tif ( p !== name ) {\n\t\t\t\t\tprop[ name ] = prop[ p ];\n\t\t\t\t\tdelete prop[ p ];\n\t\t\t\t\tp = name;\n\t\t\t\t}\n\n\t\t\t\tif ( prop[p] === \"hide\" && hidden || prop[p] === \"show\" && !hidden ) {\n\t\t\t\t\treturn opt.complete.call(this);\n\t\t\t\t}\n\n\t\t\t\tif ( ( p === \"height\" || p === \"width\" ) && this.style ) {\n\t\t\t\t\t// Store display property\n\t\t\t\t\topt.display = jQuery.css(this, \"display\");\n\n\t\t\t\t\t// Make sure that nothing sneaks out\n\t\t\t\t\topt.overflow = this.style.overflow;\n\t\t\t\t}\n\n\t\t\t\tif ( jQuery.isArray( prop[p] ) ) {\n\t\t\t\t\t// Create (if needed) and add to specialEasing\n\t\t\t\t\t(opt.specialEasing = opt.specialEasing || {})[p] = prop[p][1];\n\t\t\t\t\tprop[p] = prop[p][0];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( opt.overflow != null ) {\n\t\t\t\tthis.style.overflow = \"hidden\";\n\t\t\t}\n\n\t\t\topt.curAnim = jQuery.extend({}, prop);\n\n\t\t\tjQuery.each( prop, function( name, val ) {\n\t\t\t\tvar e = new jQuery.fx( self, opt, name );\n\n\t\t\t\tif ( rfxtypes.test(val) ) {\n\t\t\t\t\te[ val === \"toggle\" ? hidden ? \"show\" : \"hide\" : val ]( prop );\n\n\t\t\t\t} else {\n\t\t\t\t\tvar parts = rfxnum.exec(val),\n\t\t\t\t\t\tstart = e.cur(true) || 0;\n\n\t\t\t\t\tif ( parts ) {\n\t\t\t\t\t\tvar end = parseFloat( parts[2] ),\n\t\t\t\t\t\t\tunit = parts[3] || \"px\";\n\n\t\t\t\t\t\t// We need to compute starting value\n\t\t\t\t\t\tif ( unit !== \"px\" ) {\n\t\t\t\t\t\t\tself.style[ name ] = (end || 1) + unit;\n\t\t\t\t\t\t\tstart = ((end || 1) / e.cur(true)) * start;\n\t\t\t\t\t\t\tself.style[ name ] = start + unit;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n\t\t\t\t\t\tif ( parts[1] ) {\n\t\t\t\t\t\t\tend = ((parts[1] === \"-=\" ? -1 : 1) * end) + start;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\te.custom( start, end, unit );\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\te.custom( start, val, \"\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif ( jQuery.isEmptyObject( prop ) ) {\n\t\t\t\treturn optall.complete.call(this);\n\t\t\t}\n\n\t\t\t// For JS strict compliance\n\t\t\treturn true;\n\t\t});\n\t}","jQuery.fn.append":"function () {\n\t\treturn this.domManip(arguments, true, function(elem){\n\t\t\tif ( this.nodeType === 1 ) {\n\t\t\t\tthis.appendChild( elem );\n\t\t\t}\n\t\t});\n\t}","jQuery.fn.appendTo":"function ( selector ) {\n\t\tvar ret = [], insert = jQuery( selector );\n\n\t\tfor ( var i = 0, l = insert.length; i < l; i++ ) {\n\t\t\tvar elems = (i > 0 ? this.clone(true) : this).get();\n\t\t\tjQuery.fn[ original ].apply( jQuery(insert[i]), elems );\n\t\t\tret = ret.concat( elems );\n\t\t}\n\t\treturn this.pushStack( ret, name, insert.selector );\n\t}","jQuery.fn.attr":"function ( name, value ) {\n\t\treturn access( this, name, value, true, jQuery.attr );\n\t}","jQuery.fn.before":"function () {\n\t\tif ( this[0] && this[0].parentNode ) {\n\t\t\treturn this.domManip(arguments, false, function(elem){\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t});\n\t\t} else if ( arguments.length ) {\n\t\t\tvar set = jQuery(arguments[0]);\n\t\t\tset.push.apply( set, this.toArray() );\n\t\t\treturn this.pushStack( set, \"before\", arguments );\n\t\t}\n\t}","jQuery.fn.bind":"function ( type, data, fn, thisObject ) {\n\t\t// Handle object literals\n\t\tif ( typeof type === \"object\" ) {\n\t\t\tfor ( var key in type ) {\n\t\t\t\tthis[ name ](key, data, type[key], fn);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\tthisObject = fn;\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t}\n\t\tfn = thisObject === undefined ? fn : jQuery.event.proxy( fn, thisObject );\n\t\tvar handler = name == \"one\" ? jQuery.event.proxy( fn, function( event ) {\n\t\t\tjQuery( this ).unbind( event, handler );\n\t\t\treturn fn.apply( this, arguments );\n\t\t}) : fn;\n\t\treturn type === \"unload\" ? this.one(type, data, handler, thisObject) : this.each(function() {\n\t\t\tjQuery.event.add( this, type, handler, data );\n\t\t});\n\t}","jQuery.fn.blur":"function ( fn ) {\n\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t}","jQuery.fn.change":"function ( fn ) {\n\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t}","jQuery.fn.children":"function ( until, selector ) {\n\t\tvar ret = jQuery.map( this, fn, until );\n\t\t\n\t\tif ( !runtil.test( name ) ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tret = jQuery.filter( selector, ret );\n\t\t}\n\n\t\tret = this.length > 1 ? jQuery.unique( ret ) : ret;\n\n\t\tif ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {\n\t\t\tret = ret.reverse();\n\t\t}\n\n\t\treturn this.pushStack( ret, name, slice.call(arguments).join(\",\") );\n\t}","jQuery.fn.clearQueue":"function (type){\n\t\treturn this.queue( type || \"fx\", [] );\n\t}","jQuery.fn.click":"function ( fn ) {\n\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t}","jQuery.fn.clone":"function ( events ) {\n\t\t// Do the clone\n\t\tvar ret = this.map(function(){\n\t\t\tif ( !jQuery.support.noCloneEvent && !jQuery.isXMLDoc(this) ) {\n\t\t\t\t// IE copies events bound via attachEvent when\n\t\t\t\t// using cloneNode. Calling detachEvent on the\n\t\t\t\t// clone will also remove the events from the orignal\n\t\t\t\t// In order to get around this, we use innerHTML.\n\t\t\t\t// Unfortunately, this means some modifications to\n\t\t\t\t// attributes in IE that are actually only stored\n\t\t\t\t// as properties will not be copied (such as the\n\t\t\t\t// the name attribute on an input).\n\t\t\t\tvar html = this.outerHTML, ownerDocument = this.ownerDocument;\n\t\t\t\tif ( !html ) {\n\t\t\t\t\tvar div = ownerDocument.createElement(\"div\");\n\t\t\t\t\tdiv.appendChild( this.cloneNode(true) );\n\t\t\t\t\thtml = div.innerHTML;\n\t\t\t\t}\n\n\t\t\t\treturn jQuery.clean([html.replace(rinlinejQuery, \"\")\n\t\t\t\t\t.replace(rleadingWhitespace, \"\")], ownerDocument)[0];\n\t\t\t} else {\n\t\t\t\treturn this.cloneNode(true);\n\t\t\t}\n\t\t});\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( events === true ) {\n\t\t\tcloneCopyEvent( this, ret );\n\t\t\tcloneCopyEvent( this.find(\"*\"), ret.find(\"*\") );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn ret;\n\t}","jQuery.fn.closest":"function ( selectors, context ) {\n\t\tif ( jQuery.isArray( selectors ) ) {\n\t\t\tvar ret = [], cur = this[0], match, matches = {}, selector;\n\n\t\t\tif ( cur && selectors.length ) {\n\t\t\t\tfor ( var i = 0, l = selectors.length; i < l; i++ ) {\n\t\t\t\t\tselector = selectors[i];\n\n\t\t\t\t\tif ( !matches[selector] ) {\n\t\t\t\t\t\tmatches[selector] = jQuery.expr.match.POS.test( selector ) ? \n\t\t\t\t\t\t\tjQuery( selector, context || this.context ) :\n\t\t\t\t\t\t\tselector;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile ( cur && cur.ownerDocument && cur !== context ) {\n\t\t\t\t\tfor ( selector in matches ) {\n\t\t\t\t\t\tmatch = matches[selector];\n\n\t\t\t\t\t\tif ( match.jquery ? match.index(cur) > -1 : jQuery(cur).is(match) ) {\n\t\t\t\t\t\t\tret.push({ selector: selector, elem: cur });\n\t\t\t\t\t\t\tdelete matches[selector];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcur = cur.parentNode;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tvar pos = jQuery.expr.match.POS.test( selectors ) ? \n\t\t\tjQuery( selectors, context || this.context ) : null;\n\n\t\treturn this.map(function(i, cur){\n\t\t\twhile ( cur && cur.ownerDocument && cur !== context ) {\n\t\t\t\tif ( pos ? pos.index(cur) > -1 : jQuery(cur).is(selectors) ) {\n\t\t\t\t\treturn cur;\n\t\t\t\t}\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}","jQuery.fn.contents":"function ( until, selector ) {\n\t\tvar ret = jQuery.map( this, fn, until );\n\t\t\n\t\tif ( !runtil.test( name ) ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tret = jQuery.filter( selector, ret );\n\t\t}\n\n\t\tret = this.length > 1 ? jQuery.unique( ret ) : ret;\n\n\t\tif ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {\n\t\t\tret = ret.reverse();\n\t\t}\n\n\t\treturn this.pushStack( ret, name, slice.call(arguments).join(\",\") );\n\t}","jQuery.fn.css":"function ( name, value ) {\n\treturn access( this, name, value, true, function( elem, name, value ) {\n\t\tif ( value === undefined ) {\n\t\t\treturn jQuery.curCSS( elem, name );\n\t\t}\n\t\t\n\t\tif ( typeof value === \"number\" && !rexclude.test(name) ) {\n\t\t\tvalue += \"px\";\n\t\t}\n\n\t\tjQuery.style( elem, name, value );\n\t});\n}","jQuery.fn.data":"function ( key, value ){\n\t\tif ( typeof key === \"undefined\" && this.length ) {\n\t\t\treturn jQuery.data( this[0] );\n\n\t\t} else if ( typeof key === \"object\" ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery.data( this, key );\n\t\t\t});\n\t\t}\n\n\t\tvar parts = key.split(\".\");\n\t\tparts[1] = parts[1] ? \".\" + parts[1] : \"\";\n\n\t\tif ( value === undefined ) {\n\t\t\tvar data = this.triggerHandler(\"getData\" + parts[1] + \"!\", [parts[0]]);\n\n\t\t\tif ( data === undefined && this.length ) {\n\t\t\t\tdata = jQuery.data( this[0], key );\n\t\t\t}\n\t\t\treturn data === undefined && parts[1] ?\n\t\t\t\tthis.data( parts[0] ) :\n\t\t\t\tdata;\n\t\t} else {\n\t\t\treturn this.trigger(\"setData\" + parts[1] + \"!\", [parts[0], value]).each(function(){\n\t\t\t\tjQuery.data( this, key, value );\n\t\t\t});\n\t\t}\n\t}","jQuery.fn.dblclick":"function ( fn ) {\n\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t}","jQuery.fn.delay":"function ( time, type ) {\n\t\ttime = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\n\t\ttype = type || \"fx\";\n\n\t\treturn this.queue( type, function() {\n\t\t\tvar elem = this;\n\t\t\tsetTimeout(function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t}, time );\n\t\t});\n\t}","jQuery.fn.dequeue":"function (type){\n\t\treturn this.each(function(){\n\t\t\tjQuery.dequeue( this, type );\n\t\t});\n\t}","jQuery.fn.detach":"function ( selector ) {\n\t\treturn this.remove( selector, true );\n\t}","jQuery.fn.die":"function ( type, fn ) {\n\t\tjQuery( this.context ).unbind( liveConvert( type, this.selector ), fn ? { guid: fn.guid + this.selector + type } : null );\n\t\treturn this;\n\t}","jQuery.fn.domManip":"function ( args, table, callback ) {\n\t\tvar results, first, value = args[0], scripts = [];\n\n\t\tif ( jQuery.isFunction(value) ) {\n\t\t\treturn this.each(function() {\n\t\t\t\targs[0] = value.call(this);\n\t\t\t\treturn jQuery(this).domManip( args, table, callback );\n\t\t\t});\n\t\t}\n\n\t\tif ( this[0] ) {\n\t\t\t// If we're in a fragment, just use that instead of building a new one\n\t\t\tif ( args[0] && args[0].parentNode && args[0].parentNode.nodeType === 11 ) {\n\t\t\t\tresults = { fragment: args[0].parentNode };\n\t\t\t} else {\n\t\t\t\tresults = buildFragment( args, this, scripts );\n\t\t\t}\n\n\t\t\tfirst = results.fragment.firstChild;\n\n\t\t\tif ( first ) {\n\t\t\t\ttable = table && jQuery.nodeName( first, \"tr\" );\n\n\t\t\t\tfor ( var i = 0, l = this.length; i < l; i++ ) {\n\t\t\t\t\tcallback.call(\n\t\t\t\t\t\ttable ?\n\t\t\t\t\t\t\troot(this[i], first) :\n\t\t\t\t\t\t\tthis[i],\n\t\t\t\t\t\tresults.cacheable || this.length > 1 || i > 0 ?\n\t\t\t\t\t\t\tresults.fragment.cloneNode(true) :\n\t\t\t\t\t\t\tresults.fragment\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( scripts ) {\n\t\t\t\tjQuery.each( scripts, evalScript );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\n\t\tfunction root( elem, cur ) {\n\t\t\treturn jQuery.nodeName(elem, \"table\") ?\n\t\t\t\t(elem.getElementsByTagName(\"tbody\")[0] ||\n\t\t\t\telem.appendChild(elem.ownerDocument.createElement(\"tbody\"))) :\n\t\t\t\telem;\n\t\t}\n\t}","jQuery.fn.each":"function ( callback, args ) {\n\t\treturn jQuery.each( this, callback, args );\n\t}","jQuery.fn.empty":"function (){\n\t\treturn this.each( fn, arguments );\n\t}","jQuery.fn.end":"function () {\n\t\treturn this.prevObject || jQuery(null);\n\t}","jQuery.fn.eq":"function ( i ) {\n\t\treturn i === -1 ?\n\t\t\tthis.slice( i ) :\n\t\t\tthis.slice( i, +i + 1 );\n\t}","jQuery.fn.error":"function ( fn ) {\n\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t}","jQuery.fn.extend":"function () {\n\t// copy reference to target object\n\tvar target = arguments[0] || {}, i = 1, length = arguments.length, deep = false, options, name, src, copy;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\t\ttarget = {};\n\t}\n\n\t// extend jQuery itself if only one argument is passed\n\tif ( length === i ) {\n\t\ttarget = this;\n\t\t--i;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging object literal values\n\t\t\t\tif ( deep && copy && jQuery.isPlainObject(copy) ) {\n\t\t\t\t\t// Don't extend not object literals\n\t\t\t\t\tvar clone = src && jQuery.isPlainObject(src) ? src : {};\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n}","jQuery.fn.fadeIn":"function ( speed, callback ){\n\t\treturn this.animate( props, speed, callback );\n\t}","jQuery.fn.fadeOut":"function ( speed, callback ){\n\t\treturn this.animate( props, speed, callback );\n\t}","jQuery.fn.fadeTo":"function ( speed, to, callback ) {\n\t\treturn this.filter(\":hidden\").css(\"opacity\", 0).show().end()\n\t\t\t\t\t.animate({opacity: to}, speed, callback);\n\t}","jQuery.fn.filter":"function ( selector ) {\n\t\treturn this.pushStack( winnow(this, selector, true), \"filter\", selector );\n\t}","jQuery.fn.find":"function ( selector ) {\n\t\tvar ret = this.pushStack( \"\", \"find\", selector ), length = 0;\n\n\t\tfor ( var i = 0, l = this.length; i < l; i++ ) {\n\t\t\tlength = ret.length;\n\t\t\tjQuery.find( selector, this[i], ret );\n\n\t\t\tif ( i > 0 ) {\n\t\t\t\t// Make sure that the results are unique\n\t\t\t\tfor ( var n = length; n < ret.length; n++ ) {\n\t\t\t\t\tfor ( var r = 0; r < length; r++ ) {\n\t\t\t\t\t\tif ( ret[r] === ret[n] ) {\n\t\t\t\t\t\t\tret.splice(n--, 1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}","jQuery.fn.first":"function () {\n\t\treturn this.eq( 0 );\n\t}","jQuery.fn.focus":"function ( fn ) {\n\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t}","jQuery.fn.get":"function ( num ) {\n\t\treturn num == null ?\n\n\t\t\t// Return a 'clean' array\n\t\t\tthis.toArray() :\n\n\t\t\t// Return just the object\n\t\t\t( num < 0 ? this.slice(num)[ 0 ] : this[ num ] );\n\t}","jQuery.fn.has":"function ( target ) {\n\t\tvar targets = jQuery( target );\n\t\treturn this.filter(function() {\n\t\t\tfor ( var i = 0, l = targets.length; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}","jQuery.fn.hasClass":"function ( selector ) {\n\t\tvar className = \" \" + selector + \" \";\n\t\tfor ( var i = 0, l = this.length; i < l; i++ ) {\n\t\t\tif ( (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) > -1 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","jQuery.fn.height":"function ( size ) {\n\t\t// Get window width or height\n\t\tvar elem = this[0];\n\t\tif ( !elem ) {\n\t\t\treturn size == null ? null : this;\n\t\t}\n\n\t\treturn (\"scrollTo\" in elem && elem.document) ? // does it walk and quack like a window?\n\t\t\t// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode\n\t\t\telem.document.compatMode === \"CSS1Compat\" && elem.document.documentElement[ \"client\" + name ] ||\n\t\t\telem.document.body[ \"client\" + name ] :\n\n\t\t\t// Get document width or height\n\t\t\t(elem.nodeType === 9) ? // is it a document\n\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height], whichever is greater\n\t\t\t\tMath.max(\n\t\t\t\t\telem.documentElement[\"client\" + name],\n\t\t\t\t\telem.body[\"scroll\" + name], elem.documentElement[\"scroll\" + name],\n\t\t\t\t\telem.body[\"offset\" + name], elem.documentElement[\"offset\" + name]\n\t\t\t\t) :\n\n\t\t\t\t// Get or set width or height on the element\n\t\t\t\tsize === undefined ?\n\t\t\t\t\t// Get width or height on the element\n\t\t\t\t\tjQuery.css( elem, type ) :\n\n\t\t\t\t\t// Set the width or height on the element (default to pixels if value is unitless)\n\t\t\t\t\tthis.css( type, typeof size === \"string\" ? size : size + \"px\" );\n\t}","jQuery.fn.hide":"function ( speed, callback ) {\n\t\tif ( speed != null ) {\n\t\t\treturn this.animate( genFx(\"hide\", 3), speed, callback);\n\n\t\t} else {\n\t\t\tfor ( var i = 0, l = this.length; i < l; i++ ){\n\t\t\t\tvar old = jQuery.data(this[i], \"olddisplay\");\n\t\t\t\tif ( !old && old !== \"none\" ){\n\t\t\t\t\tjQuery.data(this[i], \"olddisplay\", jQuery.css(this[i], \"display\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the display of the elements in a second loop\n\t\t\t// to avoid the constant reflow\n\t\t\tfor ( var j = 0, k = this.length; j < k; j++ ){\n\t\t\t\tthis[j].style.display = \"none\";\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t}","jQuery.fn.hover":"function ( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}","jQuery.fn.html":"function ( value ) {\n\t\tif ( value === undefined ) {\n\t\t\treturn this[0] ?\n\t\t\t\tthis[0].innerHTML.replace(rinlinejQuery, \"\") :\n\t\t\t\tnull;\n\n\t\t// See if we can take a shortcut and just use innerHTML\n\t\t} else if ( typeof value === \"string\" && !/<script/i.test( value ) &&\n\t\t\t(jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) &&\n\t\t\t!wrapMap[ (rtagName.exec( value ) || [\"\", \"\"])[1].toLowerCase() ] ) {\n\n\t\t\ttry {\n\t\t\t\tfor ( var i = 0, l = this.length; i < l; i++ ) {\n\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\tif ( this[i].nodeType === 1 ) {\n\t\t\t\t\t\tcleanData( this[i].getElementsByTagName(\"*\") );\n\t\t\t\t\t\tthis[i].innerHTML = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t} catch(e) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\n\t\t} else {\n\t\t\tthis.empty().append( value );\n\t\t}\n\n\t\treturn this;\n\t}","jQuery.fn.index":"function ( elem ) {\n\t\tif ( !elem || typeof elem === \"string\" ) {\n\t\t\treturn jQuery.inArray( this[0],\n\t\t\t\t// If it receives a string, the selector is used\n\t\t\t\t// If it receives nothing, the siblings are used\n\t\t\t\telem ? jQuery( elem ) : this.parent().children() );\n\t\t}\n\t\t// Locate the position of the desired element\n\t\treturn jQuery.inArray(\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[0] : elem, this );\n\t}","jQuery.fn.init":"function ( selector, context ) {\n\t\tvar match, elem, ret, doc;\n\n\t\t// Handle $(\"\"), $(null), or $(undefined)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Handle $(DOMElement)\n\t\tif ( selector.nodeType ) {\n\t\t\tthis.context = this[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\t\t}\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\t// Are we dealing with HTML string or an ID?\n\t\t\tmatch = quickExpr.exec( selector );\n\n\t\t\t// Verify a match, and that no context was specified for #id\n\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[1] ) {\n\t\t\t\t\tdoc = (context ? context.ownerDocument || context : document);\n\n\t\t\t\t\t// If a single string is passed in and it's a single tag\n\t\t\t\t\t// just do a createElement and skip the rest\n\t\t\t\t\tret = rsingleTag.exec( selector );\n\n\t\t\t\t\tif ( ret ) {\n\t\t\t\t\t\tif ( jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\t\tselector = [ document.createElement( ret[1] ) ];\n\t\t\t\t\t\t\tjQuery.fn.attr.call( selector, context, true );\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tselector = [ doc.createElement( ret[1] ) ];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret = buildFragment( [ match[1] ], [ doc ] );\n\t\t\t\t\t\tselector = (ret.cacheable ? ret.fragment.cloneNode(true) : ret.fragment).childNodes;\n\t\t\t\t\t}\n\n\t\t\t\t// HANDLE: $(\"#id\")\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[2] );\n\n\t\t\t\t\tif ( elem ) {\n\t\t\t\t\t\t// Handle the case where IE and Opera return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id !== match[2] ) {\n\t\t\t\t\t\t\treturn rootjQuery.find( selector );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise, we inject the element directly into the jQuery object\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.context = document;\n\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(\"TAG\")\n\t\t\t} else if ( !context && /^\\w+$/.test( selector ) ) {\n\t\t\t\tthis.selector = selector;\n\t\t\t\tthis.context = document;\n\t\t\t\tselector = document.getElementsByTagName( selector );\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn (context || rootjQuery).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn jQuery( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn rootjQuery.ready( selector );\n\t\t}\n\n\t\tif (selector.selector !== undefined) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn jQuery.isArray( selector ) ?\n\t\t\tthis.setArray( selector ) :\n\t\t\tjQuery.makeArray( selector, this );\n\t}","jQuery.fn.innerHeight":"function (){\n\t\treturn this[0] ?\n\t\t\tjQuery.css( this[0], type, false, \"padding\" ) :\n\t\t\tnull;\n\t}","jQuery.fn.innerWidth":"function (){\n\t\treturn this[0] ?\n\t\t\tjQuery.css( this[0], type, false, \"padding\" ) :\n\t\t\tnull;\n\t}","jQuery.fn.insertAfter":"function ( selector ) {\n\t\tvar ret = [], insert = jQuery( selector );\n\n\t\tfor ( var i = 0, l = insert.length; i < l; i++ ) {\n\t\t\tvar elems = (i > 0 ? this.clone(true) : this).get();\n\t\t\tjQuery.fn[ original ].apply( jQuery(insert[i]), elems );\n\t\t\tret = ret.concat( elems );\n\t\t}\n\t\treturn this.pushStack( ret, name, insert.selector );\n\t}","jQuery.fn.insertBefore":"function ( selector ) {\n\t\tvar ret = [], insert = jQuery( selector );\n\n\t\tfor ( var i = 0, l = insert.length; i < l; i++ ) {\n\t\t\tvar elems = (i > 0 ? this.clone(true) : this).get();\n\t\t\tjQuery.fn[ original ].apply( jQuery(insert[i]), elems );\n\t\t\tret = ret.concat( elems );\n\t\t}\n\t\treturn this.pushStack( ret, name, insert.selector );\n\t}","jQuery.fn.is":"function ( selector ) {\n\t\treturn !!selector && jQuery.filter( selector, this ).length > 0;\n\t}","jQuery.fn.jquery":"\"1.4a2\"","jQuery.fn.keydown":"function ( fn ) {\n\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t}","jQuery.fn.keypress":"function ( fn ) {\n\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t}","jQuery.fn.keyup":"function ( fn ) {\n\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t}","jQuery.fn.last":"function () {\n\t\treturn this.eq( -1 );\n\t}","jQuery.fn.length":"0","jQuery.fn.live":"function ( type, data, fn, thisObject ) {\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\tif ( fn !== undefined ) {\n\t\t\t\tthisObject = fn;\n\t\t\t}\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t}\n\t\tjQuery( this.context ).bind( liveConvert( type, this.selector ), {\n\t\t\tdata: data, selector: this.selector, live: type\n\t\t}, fn, thisObject );\n\t\treturn this;\n\t}","jQuery.fn.load":"function ( url, params, callback ) {\n\t\tif ( typeof url !== \"string\" ) {\n\t\t\treturn this._load( url );\n\n\t\t// Don't do a request if no elements are being requested\n\t\t} else if ( !this.length ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tvar off = url.indexOf(\" \");\n\t\tif ( off >= 0 ) {\n\t\t\tvar selector = url.slice(off, url.length);\n\t\t\turl = url.slice(0, off);\n\t\t}\n\n\t\t// Default to a GET request\n\t\tvar type = \"GET\";\n\n\t\t// If the second parameter was provided\n\t\tif ( params ) {\n\t\t\t// If it's a function\n\t\t\tif ( jQuery.isFunction( params ) ) {\n\t\t\t\t// We assume that it's the callback\n\t\t\t\tcallback = params;\n\t\t\t\tparams = null;\n\n\t\t\t// Otherwise, build a param string\n\t\t\t} else if ( typeof params === \"object\" ) {\n\t\t\t\tparams = jQuery.param( params );\n\t\t\t\ttype = \"POST\";\n\t\t\t}\n\t\t}\n\n\t\t// Request the remote document\n\t\tjQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: type,\n\t\t\tdataType: \"html\",\n\t\t\tdata: params,\n\t\t\tcontext:this,\n\t\t\tcomplete: function(res, status){\n\t\t\t\t// If successful, inject the HTML into all the matched elements\n\t\t\t\tif ( status === \"success\" || status === \"notmodified\" ) {\n\t\t\t\t\t// See if a selector was specified\n\t\t\t\t\tthis.html( selector ?\n\t\t\t\t\t\t// Create a dummy div to hold the results\n\t\t\t\t\t\tjQuery(\"<div />\")\n\t\t\t\t\t\t\t// inject the contents of the document in, removing the scripts\n\t\t\t\t\t\t\t// to avoid any 'Permission Denied' errors in IE\n\t\t\t\t\t\t\t.append(res.responseText.replace(rscript, \"\"))\n\n\t\t\t\t\t\t\t// Locate the specified elements\n\t\t\t\t\t\t\t.find(selector) :\n\n\t\t\t\t\t\t// If not, just inject the full result\n\t\t\t\t\t\tres.responseText );\n\t\t\t\t}\n\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tthis.each( callback, [res.responseText, status, res] );\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}","jQuery.fn.map":"function ( callback ) {\n\t\treturn this.pushStack( jQuery.map(this, function(elem, i){\n\t\t\treturn callback.call( elem, i, elem );\n\t\t}));\n\t}","jQuery.fn.mousedown":"function ( fn ) {\n\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t}","jQuery.fn.mouseenter":"function ( fn ) {\n\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t}","jQuery.fn.mouseleave":"function ( fn ) {\n\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t}","jQuery.fn.mousemove":"function ( fn ) {\n\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t}","jQuery.fn.mouseout":"function ( fn ) {\n\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t}","jQuery.fn.mouseover":"function ( fn ) {\n\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t}","jQuery.fn.mouseup":"function ( fn ) {\n\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t}","jQuery.fn.next":"function ( until, selector ) {\n\t\tvar ret = jQuery.map( this, fn, until );\n\t\t\n\t\tif ( !runtil.test( name ) ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tret = jQuery.filter( selector, ret );\n\t\t}\n\n\t\tret = this.length > 1 ? jQuery.unique( ret ) : ret;\n\n\t\tif ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {\n\t\t\tret = ret.reverse();\n\t\t}\n\n\t\treturn this.pushStack( ret, name, slice.call(arguments).join(\",\") );\n\t}","jQuery.fn.nextAll":"function ( until, selector ) {\n\t\tvar ret = jQuery.map( this, fn, until );\n\t\t\n\t\tif ( !runtil.test( name ) ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tret = jQuery.filter( selector, ret );\n\t\t}\n\n\t\tret = this.length > 1 ? jQuery.unique( ret ) : ret;\n\n\t\tif ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {\n\t\t\tret = ret.reverse();\n\t\t}\n\n\t\treturn this.pushStack( ret, name, slice.call(arguments).join(\",\") );\n\t}","jQuery.fn.nextUntil":"function ( until, selector ) {\n\t\tvar ret = jQuery.map( this, fn, until );\n\t\t\n\t\tif ( !runtil.test( name ) ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tret = jQuery.filter( selector, ret );\n\t\t}\n\n\t\tret = this.length > 1 ? jQuery.unique( ret ) : ret;\n\n\t\tif ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {\n\t\t\tret = ret.reverse();\n\t\t}\n\n\t\treturn this.pushStack( ret, name, slice.call(arguments).join(\",\") );\n\t}","jQuery.fn.not":"function ( selector ) {\n\t\treturn this.pushStack( winnow(this, selector, false), \"not\", selector);\n\t}","jQuery.fn.offset":"function ( options ) {\n\t\tvar elem = this[0];\n\t\tif ( !elem || !elem.ownerDocument ) { return null; }\n\t\tif ( options ) { \n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery.offset.setOffset( this, options );\n\t\t\t});\n\t\t}\n\t\tif ( elem === elem.ownerDocument.body ) {\n\t\t\treturn jQuery.offset.bodyOffset( elem );\n\t\t}\n\n\t\tvar box = elem.getBoundingClientRect(), doc = elem.ownerDocument, body = doc.body, docElem = doc.documentElement,\n\t\t\tclientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,\n\t\t\ttop  = box.top  + (self.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop ) - clientTop,\n\t\t\tleft = box.left + (self.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft) - clientLeft;\n\t\treturn { top: top, left: left };\n\t}","jQuery.fn.offsetParent":"function () {\n\t\treturn this.map(function(){\n\t\t\tvar offsetParent = this.offsetParent || document.body;\n\t\t\twhile ( offsetParent && (!/^body|html$/i.test(offsetParent.nodeName) && jQuery.css(offsetParent, 'position') === 'static') ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\t\t\treturn offsetParent;\n\t\t});\n\t}","jQuery.fn.one":"function ( type, data, fn, thisObject ) {\n\t\t// Handle object literals\n\t\tif ( typeof type === \"object\" ) {\n\t\t\tfor ( var key in type ) {\n\t\t\t\tthis[ name ](key, data, type[key], fn);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\tthisObject = fn;\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t}\n\t\tfn = thisObject === undefined ? fn : jQuery.event.proxy( fn, thisObject );\n\t\tvar handler = name == \"one\" ? jQuery.event.proxy( fn, function( event ) {\n\t\t\tjQuery( this ).unbind( event, handler );\n\t\t\treturn fn.apply( this, arguments );\n\t\t}) : fn;\n\t\treturn type === \"unload\" ? this.one(type, data, handler, thisObject) : this.each(function() {\n\t\t\tjQuery.event.add( this, type, handler, data );\n\t\t});\n\t}","jQuery.fn.outerHeight":"function (margin) {\n\t\treturn this[0] ?\n\t\t\tjQuery.css( this[0], type, false, margin ? \"margin\" : \"border\" ) :\n\t\t\tnull;\n\t}","jQuery.fn.outerWidth":"function (margin) {\n\t\treturn this[0] ?\n\t\t\tjQuery.css( this[0], type, false, margin ? \"margin\" : \"border\" ) :\n\t\t\tnull;\n\t}","jQuery.fn.parent":"function ( until, selector ) {\n\t\tvar ret = jQuery.map( this, fn, until );\n\t\t\n\t\tif ( !runtil.test( name ) ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tret = jQuery.filter( selector, ret );\n\t\t}\n\n\t\tret = this.length > 1 ? jQuery.unique( ret ) : ret;\n\n\t\tif ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {\n\t\t\tret = ret.reverse();\n\t\t}\n\n\t\treturn this.pushStack( ret, name, slice.call(arguments).join(\",\") );\n\t}","jQuery.fn.parents":"function ( until, selector ) {\n\t\tvar ret = jQuery.map( this, fn, until );\n\t\t\n\t\tif ( !runtil.test( name ) ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tret = jQuery.filter( selector, ret );\n\t\t}\n\n\t\tret = this.length > 1 ? jQuery.unique( ret ) : ret;\n\n\t\tif ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {\n\t\t\tret = ret.reverse();\n\t\t}\n\n\t\treturn this.pushStack( ret, name, slice.call(arguments).join(\",\") );\n\t}","jQuery.fn.parentsUntil":"function ( until, selector ) {\n\t\tvar ret = jQuery.map( this, fn, until );\n\t\t\n\t\tif ( !runtil.test( name ) ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tret = jQuery.filter( selector, ret );\n\t\t}\n\n\t\tret = this.length > 1 ? jQuery.unique( ret ) : ret;\n\n\t\tif ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {\n\t\t\tret = ret.reverse();\n\t\t}\n\n\t\treturn this.pushStack( ret, name, slice.call(arguments).join(\",\") );\n\t}","jQuery.fn.position":"function () {\n\t\tif ( !this[0] ) { return null; }\n\n\t\tvar elem = this[0],\n\n\t\t// Get *real* offsetParent\n\t\toffsetParent = this.offsetParent(),\n\n\t\t// Get correct offsets\n\t\toffset       = this.offset(),\n\t\tparentOffset = /^body|html$/i.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();\n\n\t\t// Subtract element margins\n\t\t// note: when an element has margin: auto the offsetLeft and marginLeft\n\t\t// are the same in Safari causing offset.left to incorrectly be 0\n\t\toffset.top  -= parseFloat( jQuery.curCSS(elem, 'marginTop',  true) ) || 0;\n\t\toffset.left -= parseFloat( jQuery.curCSS(elem, 'marginLeft', true) ) || 0;\n\n\t\t// Add offsetParent borders\n\t\tparentOffset.top  += parseFloat( jQuery.curCSS(offsetParent[0], 'borderTopWidth',  true) ) || 0;\n\t\tparentOffset.left += parseFloat( jQuery.curCSS(offsetParent[0], 'borderLeftWidth', true) ) || 0;\n\n\t\t// Subtract the two offsets\n\t\treturn {\n\t\t\ttop:  offset.top  - parentOffset.top,\n\t\t\tleft: offset.left - parentOffset.left\n\t\t};\n\t}","jQuery.fn.prepend":"function () {\n\t\treturn this.domManip(arguments, true, function(elem){\n\t\t\tif ( this.nodeType === 1 ) {\n\t\t\t\tthis.insertBefore( elem, this.firstChild );\n\t\t\t}\n\t\t});\n\t}","jQuery.fn.prependTo":"function ( selector ) {\n\t\tvar ret = [], insert = jQuery( selector );\n\n\t\tfor ( var i = 0, l = insert.length; i < l; i++ ) {\n\t\t\tvar elems = (i > 0 ? this.clone(true) : this).get();\n\t\t\tjQuery.fn[ original ].apply( jQuery(insert[i]), elems );\n\t\t\tret = ret.concat( elems );\n\t\t}\n\t\treturn this.pushStack( ret, name, insert.selector );\n\t}","jQuery.fn.prev":"function ( until, selector ) {\n\t\tvar ret = jQuery.map( this, fn, until );\n\t\t\n\t\tif ( !runtil.test( name ) ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tret = jQuery.filter( selector, ret );\n\t\t}\n\n\t\tret = this.length > 1 ? jQuery.unique( ret ) : ret;\n\n\t\tif ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {\n\t\t\tret = ret.reverse();\n\t\t}\n\n\t\treturn this.pushStack( ret, name, slice.call(arguments).join(\",\") );\n\t}","jQuery.fn.prevAll":"function ( until, selector ) {\n\t\tvar ret = jQuery.map( this, fn, until );\n\t\t\n\t\tif ( !runtil.test( name ) ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tret = jQuery.filter( selector, ret );\n\t\t}\n\n\t\tret = this.length > 1 ? jQuery.unique( ret ) : ret;\n\n\t\tif ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {\n\t\t\tret = ret.reverse();\n\t\t}\n\n\t\treturn this.pushStack( ret, name, slice.call(arguments).join(\",\") );\n\t}","jQuery.fn.prevUntil":"function ( until, selector ) {\n\t\tvar ret = jQuery.map( this, fn, until );\n\t\t\n\t\tif ( !runtil.test( name ) ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tret = jQuery.filter( selector, ret );\n\t\t}\n\n\t\tret = this.length > 1 ? jQuery.unique( ret ) : ret;\n\n\t\tif ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {\n\t\t\tret = ret.reverse();\n\t\t}\n\n\t\treturn this.pushStack( ret, name, slice.call(arguments).join(\",\") );\n\t}","jQuery.fn.push":"function push() { [native code] }","jQuery.fn.pushStack":"function ( elems, name, selector ) {\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery( elems || null );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\tret.context = this.context;\n\n\t\tif ( name === \"find\" ) {\n\t\t\tret.selector = this.selector + (this.selector ? \" \" : \"\") + selector;\n\t\t} else if ( name ) {\n\t\t\tret.selector = this.selector + \".\" + name + \"(\" + selector + \")\";\n\t\t}\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t}","jQuery.fn.queue":"function (type, data){\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t}\n\n\t\tif ( data === undefined ) {\n\t\t\treturn jQuery.queue( this[0], type );\n\t\t}\n\t\treturn this.each(function(i, elem){\n\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\tif ( type == \"fx\" && queue[0] !== \"inprogress\" ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t});\n\t}","jQuery.fn.ready":"function ( fn ) {\n\t\t// Attach the listeners\n\t\tjQuery.bindReady();\n\n\t\t// If the DOM is already ready\n\t\tif ( jQuery.isReady ) {\n\t\t\t// Execute the function immediately\n\t\t\tfn.call( document, jQuery );\n\n\t\t// Otherwise, remember the function for later\n\t\t} else if ( readyList ) {\n\t\t\t// Add the function to the wait list\n\t\t\treadyList.push( fn );\n\t\t}\n\n\t\treturn this;\n\t}","jQuery.fn.remove":"function (){\n\t\treturn this.each( fn, arguments );\n\t}","jQuery.fn.removeAttr":"function (val, state){\n\t\tif ( jQuery.isFunction( val ) ) {\n\t\t\treturn this.each(function() { jQuery(this)[ name ]( val.call(this), state ); });\n\t\t}\n\n\t\treturn this.each( fn, arguments );\n\t}","jQuery.fn.removeClass":"function ( value ) {\n\t\tif ( jQuery.isFunction(value) ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery(this).removeClass( value.call(this) );\n\t\t\t});\n\t\t}\n\n\t\tif ( (value && typeof value === \"string\") || value === undefined ) {\n\t\t\tvar classNames = (value || \"\").split(rspace);\n\n\t\t\tfor ( var i = 0, l = this.length; i < l; i++ ) {\n\t\t\t\tvar elem = this[i];\n\n\t\t\t\tif ( elem.nodeType === 1 && elem.className ) {\n\t\t\t\t\tif ( value ) {\n\t\t\t\t\t\tvar className = (\" \" + elem.className + \" \").replace(rclass, \" \");\n\t\t\t\t\t\tfor ( var c = 0, cl = classNames.length; c < cl; c++ ) {\n\t\t\t\t\t\t\tclassName = className.replace(\" \" + classNames[c] + \" \", \" \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telem.className = className.substring(1, className.length - 1);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\telem.className = \"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}","jQuery.fn.removeData":"function ( key ){\n\t\treturn this.each(function(){\n\t\t\tjQuery.removeData( this, key );\n\t\t});\n\t}","jQuery.fn.replaceAll":"function ( selector ) {\n\t\tvar ret = [], insert = jQuery( selector );\n\n\t\tfor ( var i = 0, l = insert.length; i < l; i++ ) {\n\t\t\tvar elems = (i > 0 ? this.clone(true) : this).get();\n\t\t\tjQuery.fn[ original ].apply( jQuery(insert[i]), elems );\n\t\t\tret = ret.concat( elems );\n\t\t}\n\t\treturn this.pushStack( ret, name, insert.selector );\n\t}","jQuery.fn.replaceWith":"function ( value ) {\n\t\tif ( this[0] && this[0].parentNode ) {\n\t\t\treturn this.each(function(){\n\t\t\t\tvar next = this.nextSibling, parent = this.parentNode;\n\n\t\t\t\tjQuery(this).remove();\n\n\t\t\t\tif ( next ) {\n\t\t\t\t\tjQuery(next).before( value );\n\t\t\t\t} else {\n\t\t\t\t\tjQuery(parent).append( value );\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\treturn this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), \"replaceWith\", value );\n\t\t}\n\t}","jQuery.fn.resize":"function ( fn ) {\n\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t}","jQuery.fn.scroll":"function ( fn ) {\n\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t}","jQuery.fn.scrollLeft":"function (val) {\n\t\tvar elem = this[0], win;\n\t\t\n\t\tif ( !elem ) { return null; }\n\n\t\tif ( val !== undefined ) {\n\t\t\t// Set the scroll offset\n\t\t\treturn this.each(function() {\n\t\t\t\twin = getWindow( this );\n\n\t\t\t\twin ?\n\t\t\t\t\twin.scrollTo(\n\t\t\t\t\t\t!i ? val : jQuery(win).scrollLeft(),\n\t\t\t\t\t\t i ? val : jQuery(win).scrollTop()\n\t\t\t\t\t) :\n\t\t\t\t\tthis[ method ] = val;\n\t\t\t});\n\t\t} else {\n\t\t\twin = getWindow( elem );\n\n\t\t\t// Return the scroll offset\n\t\t\treturn win ? ('pageXOffset' in win) ? win[ i ? 'pageYOffset' : 'pageXOffset' ] :\n\t\t\t\tjQuery.support.boxModel && win.document.documentElement[ method ] ||\n\t\t\t\t\twin.document.body[ method ] :\n\t\t\t\telem[ method ];\n\t\t}\n\t}","jQuery.fn.scrollTop":"function (val) {\n\t\tvar elem = this[0], win;\n\t\t\n\t\tif ( !elem ) { return null; }\n\n\t\tif ( val !== undefined ) {\n\t\t\t// Set the scroll offset\n\t\t\treturn this.each(function() {\n\t\t\t\twin = getWindow( this );\n\n\t\t\t\twin ?\n\t\t\t\t\twin.scrollTo(\n\t\t\t\t\t\t!i ? val : jQuery(win).scrollLeft(),\n\t\t\t\t\t\t i ? val : jQuery(win).scrollTop()\n\t\t\t\t\t) :\n\t\t\t\t\tthis[ method ] = val;\n\t\t\t});\n\t\t} else {\n\t\t\twin = getWindow( elem );\n\n\t\t\t// Return the scroll offset\n\t\t\treturn win ? ('pageXOffset' in win) ? win[ i ? 'pageYOffset' : 'pageXOffset' ] :\n\t\t\t\tjQuery.support.boxModel && win.document.documentElement[ method ] ||\n\t\t\t\t\twin.document.body[ method ] :\n\t\t\t\telem[ method ];\n\t\t}\n\t}","jQuery.fn.select":"function ( fn ) {\n\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t}","jQuery.fn.selector":"\"\"","jQuery.fn.serialize":"function () {\n\t\treturn jQuery.param(this.serializeArray());\n\t}","jQuery.fn.serializeArray":"function () {\n\t\treturn this.map(function(){\n\t\t\treturn this.elements ? jQuery.makeArray(this.elements) : this;\n\t\t})\n\t\t.filter(function(){\n\t\t\treturn this.name && !this.disabled &&\n\t\t\t\t(this.checked || rselectTextarea.test(this.nodeName) ||\n\t\t\t\t\trinput.test(this.type));\n\t\t})\n\t\t.map(function(i, elem){\n\t\t\tvar val = jQuery(this).val();\n\n\t\t\treturn val == null ?\n\t\t\t\tnull :\n\t\t\t\tjQuery.isArray(val) ?\n\t\t\t\t\tjQuery.map( val, function(val, i){\n\t\t\t\t\t\treturn {name: elem.name, value: val};\n\t\t\t\t\t}) :\n\t\t\t\t\t{name: elem.name, value: val};\n\t\t}).get();\n\t}","jQuery.fn.setArray":"function ( elems ) {\n\t\t// Resetting the length to 0, then using the native Array push\n\t\t// is a super-fast way to populate an object with array-like properties\n\t\tthis.length = 0;\n\t\tpush.apply( this, elems );\n\n\t\treturn this;\n\t}","jQuery.fn.show":"function ( speed, callback ) {\n\t\tif ( speed != null ) {\n\t\t\treturn this.animate( genFx(\"show\", 3), speed, callback);\n\n\t\t} else {\n\t\t\tfor ( var i = 0, l = this.length; i < l; i++ ){\n\t\t\t\tvar old = jQuery.data(this[i], \"olddisplay\");\n\n\t\t\t\tthis[i].style.display = old || \"\";\n\n\t\t\t\tif ( jQuery.css(this[i], \"display\") === \"none\" ) {\n\t\t\t\t\tvar nodeName = this[i].nodeName, display;\n\n\t\t\t\t\tif ( elemdisplay[ nodeName ] ) {\n\t\t\t\t\t\tdisplay = elemdisplay[ nodeName ];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar elem = jQuery(\"<\" + nodeName + \" />\").appendTo(\"body\");\n\n\t\t\t\t\t\tdisplay = elem.css(\"display\");\n\n\t\t\t\t\t\tif ( display === \"none\" ) {\n\t\t\t\t\t\t\tdisplay = \"block\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telem.remove();\n\n\t\t\t\t\t\telemdisplay[ nodeName ] = display;\n\t\t\t\t\t}\n\n\t\t\t\t\tjQuery.data(this[i], \"olddisplay\", display);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the display of the elements in a second loop\n\t\t\t// to avoid the constant reflow\n\t\t\tfor ( var j = 0, k = this.length; j < k; j++ ){\n\t\t\t\tthis[j].style.display = jQuery.data(this[j], \"olddisplay\") || \"\";\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t}","jQuery.fn.siblings":"function ( until, selector ) {\n\t\tvar ret = jQuery.map( this, fn, until );\n\t\t\n\t\tif ( !runtil.test( name ) ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tret = jQuery.filter( selector, ret );\n\t\t}\n\n\t\tret = this.length > 1 ? jQuery.unique( ret ) : ret;\n\n\t\tif ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {\n\t\t\tret = ret.reverse();\n\t\t}\n\n\t\treturn this.pushStack( ret, name, slice.call(arguments).join(\",\") );\n\t}","jQuery.fn.size":"function () {\n\t\treturn this.length;\n\t}","jQuery.fn.slice":"function () {\n\t\treturn this.pushStack( slice.apply( this, arguments ),\n\t\t\t\"slice\", slice.call(arguments).join(\",\") );\n\t}","jQuery.fn.slideDown":"function ( speed, callback ){\n\t\treturn this.animate( props, speed, callback );\n\t}","jQuery.fn.slideToggle":"function ( speed, callback ){\n\t\treturn this.animate( props, speed, callback );\n\t}","jQuery.fn.slideUp":"function ( speed, callback ){\n\t\treturn this.animate( props, speed, callback );\n\t}","jQuery.fn.sort":"function sort() { [native code] }","jQuery.fn.splice":"function splice() { [native code] }","jQuery.fn.stop":"function (clearQueue, gotoEnd){\n\t\tvar timers = jQuery.timers;\n\n\t\tif ( clearQueue ) {\n\t\t\tthis.queue([]);\n\t\t}\n\n\t\tthis.each(function(){\n\t\t\t// go in reverse order so anything added to the queue during the loop is ignored\n\t\t\tfor ( var i = timers.length - 1; i >= 0; i-- ) {\n\t\t\t\tif ( timers[i].elem === this ) {\n\t\t\t\t\tif (gotoEnd) {\n\t\t\t\t\t\t// force the next step to be the last\n\t\t\t\t\t\ttimers[i](true);\n\t\t\t\t\t}\n\n\t\t\t\t\ttimers.splice(i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// start the next in the queue if the last step wasn't forced\n\t\tif ( !gotoEnd ) {\n\t\t\tthis.dequeue();\n\t\t}\n\n\t\treturn this;\n\t}","jQuery.fn.submit":"function ( fn ) {\n\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t}","jQuery.fn.text":"function ( text ) {\n\t\tif(jQuery.isFunction(text)) {\n\t\t\treturn this.each(function() {\n\t\t\t\treturn jQuery(this).text( text.call(this) );\n\t\t\t});\n\t\t}\n\n\t\tif ( typeof text !== \"object\" && text !== undefined ) {\n\t\t\treturn this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );\n\t\t}\n\n\t\treturn jQuery.getText( this );\n\t}","jQuery.fn.toArray":"function (){\n\t\treturn slice.call( this, 0 );\n\t}","jQuery.fn.toggle":"function ( fn, fn2 ) {\n\t\tvar bool = typeof fn === \"boolean\";\n\n\t\tif ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {\n\t\t\tthis._toggle.apply( this, arguments );\n\n\t\t} else if ( fn == null || bool ) {\n\t\t\tthis.each(function(){\n\t\t\t\tvar state = bool ? fn : jQuery(this).is(\":hidden\");\n\t\t\t\tjQuery(this)[ state ? \"show\" : \"hide\" ]();\n\t\t\t});\n\n\t\t} else {\n\t\t\tthis.animate(genFx(\"toggle\", 3), fn, fn2);\n\t\t}\n\n\t\treturn this;\n\t}","jQuery.fn.toggleClass":"function (val, state){\n\t\tif ( jQuery.isFunction( val ) ) {\n\t\t\treturn this.each(function() { jQuery(this)[ name ]( val.call(this), state ); });\n\t\t}\n\n\t\treturn this.each( fn, arguments );\n\t}","jQuery.fn.trigger":"function ( type, data ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t});\n\t}","jQuery.fn.triggerHandler":"function ( type, data ) {\n\t\tif ( this[0] ) {\n\t\t\tvar event = jQuery.Event( type );\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\t\t\tjQuery.event.trigger( event, data, this[0] );\n\t\t\treturn event.result;\n\t\t}\n\t}","jQuery.fn.unbind":"function ( type, fn ) {\n\t\t// Handle object literals\n\t\tif ( typeof type === \"object\" && !type.preventDefault ) {\n\t\t\tfor ( var key in type ) {\n\t\t\t\tthis.unbind(key, type[key]);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.remove( this, type, fn );\n\t\t});\n\t}","jQuery.fn.unload":"function ( fn ) {\n\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t}","jQuery.fn.unwrap":"function () {\n\t\treturn this.parent().each(function(){\n\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t}\n\t\t}).end();\n\t}","jQuery.fn.val":"function ( value ) {\n\t\tif ( value === undefined ) {\n\t\t\tvar elem = this[0];\n\n\t\t\tif ( elem ) {\n\t\t\t\tif ( jQuery.nodeName( elem, \"option\" ) ) {\n\t\t\t\t\treturn (elem.attributes.value || {}).specified ? elem.value : elem.text;\n\t\t\t\t}\n\n\t\t\t\t// We need to handle select boxes special\n\t\t\t\tif ( jQuery.nodeName( elem, \"select\" ) ) {\n\t\t\t\t\tvar index = elem.selectedIndex,\n\t\t\t\t\t\tvalues = [],\n\t\t\t\t\t\toptions = elem.options,\n\t\t\t\t\t\tone = elem.type === \"select-one\";\n\n\t\t\t\t\t// Nothing was selected\n\t\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Loop through all the selected options\n\t\t\t\t\tfor ( var i = one ? index : 0, max = one ? index + 1 : options.length; i < max; i++ ) {\n\t\t\t\t\t\tvar option = options[ i ];\n\n\t\t\t\t\t\tif ( option.selected ) {\n\t\t\t\t\t\t\t// Get the specifc value for the option\n\t\t\t\t\t\t\tvalue = jQuery(option).val();\n\n\t\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn values;\n\t\t\t\t}\n\n\t\t\t\t// Everything else, we just grab the value\n\t\t\t\treturn (elem.value || \"\").replace(rreturn, \"\");\n\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Typecast once if the value is a number\n\t\tif ( typeof value === \"number\" ) {\n\t\t\tvalue += '';\n\t\t}\n\n\t\tvar val = value;\n\n\t\treturn this.each(function(){\n\t\t\tif ( jQuery.isFunction(value) ) {\n\t\t\t\tval = value.call(this);\n\n\t\t\t\t// Typecast each time if the value is a Function and the appended\n\t\t\t\t// value is therefore different each time.\n\t\t\t\tif ( typeof val === \"number\" ) {\n\t\t\t\t\tval += '';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( jQuery.isArray(val) && /radio|checkbox/.test( this.type ) ) {\n\t\t\t\tthis.checked = jQuery.inArray(this.value || this.name, val) >= 0;\n\n\t\t\t} else if ( jQuery.nodeName( this, \"select\" ) ) {\n\t\t\t\tvar values = jQuery.makeArray(val);\n\n\t\t\t\tjQuery( \"option\", this ).each(function(){\n\t\t\t\t\tthis.selected = jQuery.inArray( this.value || this.text, values ) >= 0;\n\t\t\t\t});\n\n\t\t\t\tif ( !values.length ) {\n\t\t\t\t\tthis.selectedIndex = -1;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t});\n\t}","jQuery.fn.width":"function ( size ) {\n\t\t// Get window width or height\n\t\tvar elem = this[0];\n\t\tif ( !elem ) {\n\t\t\treturn size == null ? null : this;\n\t\t}\n\n\t\treturn (\"scrollTo\" in elem && elem.document) ? // does it walk and quack like a window?\n\t\t\t// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode\n\t\t\telem.document.compatMode === \"CSS1Compat\" && elem.document.documentElement[ \"client\" + name ] ||\n\t\t\telem.document.body[ \"client\" + name ] :\n\n\t\t\t// Get document width or height\n\t\t\t(elem.nodeType === 9) ? // is it a document\n\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height], whichever is greater\n\t\t\t\tMath.max(\n\t\t\t\t\telem.documentElement[\"client\" + name],\n\t\t\t\t\telem.body[\"scroll\" + name], elem.documentElement[\"scroll\" + name],\n\t\t\t\t\telem.body[\"offset\" + name], elem.documentElement[\"offset\" + name]\n\t\t\t\t) :\n\n\t\t\t\t// Get or set width or height on the element\n\t\t\t\tsize === undefined ?\n\t\t\t\t\t// Get width or height on the element\n\t\t\t\t\tjQuery.css( elem, type ) :\n\n\t\t\t\t\t// Set the width or height on the element (default to pixels if value is unitless)\n\t\t\t\t\tthis.css( type, typeof size === \"string\" ? size : size + \"px\" );\n\t}","jQuery.fn.wrap":"function ( html ) {\n\t\treturn this.each(function(){\n\t\t\tjQuery( this ).wrapAll( html );\n\t\t});\n\t}","jQuery.fn.wrapAll":"function ( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery(this).wrapAll( html.apply(this, arguments) );\n\t\t\t});\n\t\t}\n\n\t\tif ( this[0] ) {\n\t\t\t// The elements to wrap the target around\n\t\t\tvar wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);\n\n\t\t\tif ( this[0].parentNode ) {\n\t\t\t\twrap.insertBefore( this[0] );\n\t\t\t}\n\n\t\t\twrap.map(function(){\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstChild && elem.firstChild.nodeType === 1 ) {\n\t\t\t\t\telem = elem.firstChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t}).append(this);\n\t\t}\n\n\t\treturn this;\n\t}","jQuery.fn.wrapInner":"function ( html ) {\n\t\treturn this.each(function(){\n\t\t\tjQuery( this ).contents().wrapAll( html );\n\t\t});\n\t}","jQuery.noData.applet":"true","jQuery.noData.embed":"true","jQuery.noData.object":"true","jQuery.offset.bodyOffset":"function ( body ) {\n\t\tvar top = body.offsetTop, left = body.offsetLeft;\n\n\t\tjQuery.offset.initialize();\n\n\t\tif ( jQuery.offset.doesNotIncludeMarginInBodyOffset ) {\n\t\t\ttop  += parseFloat( jQuery.curCSS(body, 'marginTop',  true) ) || 0;\n\t\t\tleft += parseFloat( jQuery.curCSS(body, 'marginLeft', true) ) || 0;\n\t\t}\n\n\t\treturn { top: top, left: left };\n\t}","jQuery.offset.initialize":"function () {\n\t\tvar body = document.body, container = document.createElement('div'), innerDiv, checkDiv, table, td, bodyMarginTop = parseFloat( jQuery.curCSS(body, 'marginTop', true) ) || 0,\n\t\t\thtml = '<div style=\"position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;\"><div></div></div><table style=\"position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;\" cellpadding=\"0\" cellspacing=\"0\"><tr><td></td></tr></table>';\n\n\t\tjQuery.extend( container.style, { position: 'absolute', top: 0, left: 0, margin: 0, border: 0, width: '1px', height: '1px', visibility: 'hidden' } );\n\n\t\tcontainer.innerHTML = html;\n\t\tbody.insertBefore( container, body.firstChild );\n\t\tinnerDiv = container.firstChild;\n\t\tcheckDiv = innerDiv.firstChild;\n\t\ttd = innerDiv.nextSibling.firstChild.firstChild;\n\n\t\tthis.doesNotAddBorder = (checkDiv.offsetTop !== 5);\n\t\tthis.doesAddBorderForTableAndCells = (td.offsetTop === 5);\n\n\t\tcheckDiv.style.position = 'fixed', checkDiv.style.top = '20px';\n\t\t// safari subtracts parent border width here which is 5px\n\t\tthis.supportsFixedPosition = (checkDiv.offsetTop === 20 || checkDiv.offsetTop === 15);\n\t\tcheckDiv.style.position = checkDiv.style.top = '';\n\n\t\tinnerDiv.style.overflow = 'hidden', innerDiv.style.position = 'relative';\n\t\tthis.subtractsBorderForOverflowNotVisible = (checkDiv.offsetTop === -5);\n\n\t\tthis.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== bodyMarginTop);\n\n\t\tbody.removeChild( container );\n\t\tbody = container = innerDiv = checkDiv = table = td = null;\n\t\tjQuery.offset.initialize = function(){};\n\t}","jQuery.offset.setOffset":"function ( elem, options ) {\n\t\t// set position first, in-case top/left are set even on static elem\n\t\tif ( /static/.test( jQuery.curCSS( elem, 'position' ) ) ) {\n\t\t\telem.style.position = 'relative';\n\t\t}\n\t\tvar curElem   = jQuery( elem ),\n\t\t\tcurOffset = curElem.offset(),\n\t\t\tcurTop    = parseInt( jQuery.curCSS( elem, 'top',  true ), 10 ) || 0,\n\t\t\tcurLeft   = parseInt( jQuery.curCSS( elem, 'left', true ), 10)  || 0,\n\t\t\tprops     = {\n\t\t\t\ttop:  (options.top  - curOffset.top)  + curTop,\n\t\t\t\tleft: (options.left - curOffset.left) + curLeft\n\t\t\t};\n\t\t\n\t\tif ( 'using' in options ) {\n\t\t\toptions.using.call( elem, props );\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}","jQuery.props.cellspacing":"\"cellSpacing\"","jQuery.props.class":"\"className\"","jQuery.props.colspan":"\"colSpan\"","jQuery.props.for":"\"htmlFor\"","jQuery.props.frameborder":"\"frameBorder\"","jQuery.props.maxlength":"\"maxLength\"","jQuery.props.readonly":"\"readOnly\"","jQuery.props.rowspan":"\"rowSpan\"","jQuery.props.tabindex":"\"tabIndex\"","jQuery.props.usemap":"\"useMap\"","jQuery.support.boxModel":"true","jQuery.support.changeBubbles":"true","jQuery.support.cssFloat":"true","jQuery.support.focusBubbles":"true","jQuery.support.hrefNormalized":"true","jQuery.support.htmlSerialize":"true","jQuery.support.leadingWhitespace":"true","jQuery.support.noCloneEvent":"true","jQuery.support.opacity":"true","jQuery.support.scriptEval":"true","jQuery.support.style":"true","jQuery.support.submitBubbles":"true","jQuery.support.tbody":"true","jQuery.ajaxSettings.accepts._default":"\"*/*\"","jQuery.ajaxSettings.accepts.html":"\"text/html\"","jQuery.ajaxSettings.accepts.json":"\"application/json, text/javascript\"","jQuery.ajaxSettings.accepts.script":"\"text/javascript, application/javascript\"","jQuery.ajaxSettings.accepts.text":"\"text/plain\"","jQuery.ajaxSettings.accepts.xml":"\"application/xml, text/xml\"","jQuery.expr.:.animated":"function (elem){\n\t\treturn jQuery.grep(jQuery.timers, function(fn){\n\t\t\treturn elem === fn.elem;\n\t\t}).length;\n\t}","jQuery.expr.:.button":"function (elem){\n\t\t\treturn \"button\" === elem.type || elem.nodeName.toLowerCase() === \"button\";\n\t\t}","jQuery.expr.:.checkbox":"function (elem){\n\t\t\treturn \"checkbox\" === elem.type;\n\t\t}","jQuery.expr.:.checked":"function (elem){\n\t\t\treturn elem.checked === true;\n\t\t}","jQuery.expr.:.disabled":"function (elem){\n\t\t\treturn elem.disabled === true;\n\t\t}","jQuery.expr.:.empty":"function (elem){\n\t\t\treturn !elem.firstChild;\n\t\t}","jQuery.expr.:.enabled":"function (elem){\n\t\t\treturn elem.disabled === false && elem.type !== \"hidden\";\n\t\t}","jQuery.expr.:.file":"function (elem){\n\t\t\treturn \"file\" === elem.type;\n\t\t}","jQuery.expr.:.has":"function (elem, i, match){\n\t\t\treturn !!Sizzle( match[3], elem ).length;\n\t\t}","jQuery.expr.:.header":"function (elem){\n\t\t\treturn /h\\d/i.test( elem.nodeName );\n\t\t}","jQuery.expr.:.hidden":"function ( elem ) {\n\t\tvar width = elem.offsetWidth, height = elem.offsetHeight,\n\t\t\tskip = elem.nodeName.toLowerCase() === \"tr\";\n\n\t\treturn width === 0 && height === 0 && !skip ?\n\t\t\ttrue :\n\t\t\twidth > 0 && height > 0 && !skip ?\n\t\t\t\tfalse :\n\t\t\t\tjQuery.curCSS(elem, \"display\") === \"none\";\n\t}","jQuery.expr.:.image":"function (elem){\n\t\t\treturn \"image\" === elem.type;\n\t\t}","jQuery.expr.:.input":"function (elem){\n\t\t\treturn /input|select|textarea|button/i.test(elem.nodeName);\n\t\t}","jQuery.expr.:.parent":"function (elem){\n\t\t\treturn !!elem.firstChild;\n\t\t}","jQuery.expr.:.password":"function (elem){\n\t\t\treturn \"password\" === elem.type;\n\t\t}","jQuery.expr.:.radio":"function (elem){\n\t\t\treturn \"radio\" === elem.type;\n\t\t}","jQuery.expr.:.reset":"function (elem){\n\t\t\treturn \"reset\" === elem.type;\n\t\t}","jQuery.expr.:.selected":"function (elem){\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\telem.parentNode.selectedIndex;\n\t\t\treturn elem.selected === true;\n\t\t}","jQuery.expr.:.submit":"function (elem){\n\t\t\treturn \"submit\" === elem.type;\n\t\t}","jQuery.expr.:.text":"function (elem){\n\t\t\treturn \"text\" === elem.type;\n\t\t}","jQuery.expr.:.visible":"function ( elem ) {\n\t\treturn !jQuery.expr.filters.hidden( elem );\n\t}","jQuery.expr.attrHandle.href":"function (elem){\n\t\t\treturn elem.getAttribute(\"href\");\n\t\t}","jQuery.expr.attrMap.class":"\"className\"","jQuery.expr.attrMap.for":"\"htmlFor\"","jQuery.expr.filter.ATTR":"function (elem, match){\n\t\t\tvar name = match[1],\n\t\t\t\tresult = Expr.attrHandle[ name ] ?\n\t\t\t\t\tExpr.attrHandle[ name ]( elem ) :\n\t\t\t\t\telem[ name ] != null ?\n\t\t\t\t\t\telem[ name ] :\n\t\t\t\t\t\telem.getAttribute( name ),\n\t\t\t\tvalue = result + \"\",\n\t\t\t\ttype = match[2],\n\t\t\t\tcheck = match[4];\n\n\t\t\treturn result == null ?\n\t\t\t\ttype === \"!=\" :\n\t\t\t\ttype === \"=\" ?\n\t\t\t\tvalue === check :\n\t\t\t\ttype === \"*=\" ?\n\t\t\t\tvalue.indexOf(check) >= 0 :\n\t\t\t\ttype === \"~=\" ?\n\t\t\t\t(\" \" + value + \" \").indexOf(check) >= 0 :\n\t\t\t\t!check ?\n\t\t\t\tvalue && result !== false :\n\t\t\t\ttype === \"!=\" ?\n\t\t\t\tvalue != check :\n\t\t\t\ttype === \"^=\" ?\n\t\t\t\tvalue.indexOf(check) === 0 :\n\t\t\t\ttype === \"$=\" ?\n\t\t\t\tvalue.substr(value.length - check.length) === check :\n\t\t\t\ttype === \"|=\" ?\n\t\t\t\tvalue === check || value.substr(0, check.length + 1) === check + \"-\" :\n\t\t\t\tfalse;\n\t\t}","jQuery.expr.filter.CHILD":"function (elem, match){\n\t\t\tvar type = match[1], node = elem;\n\t\t\tswitch (type) {\n\t\t\t\tcase 'only':\n\t\t\t\tcase 'first':\n\t\t\t\t\twhile ( (node = node.previousSibling) )\t {\n\t\t\t\t\t\tif ( node.nodeType === 1 ) { \n\t\t\t\t\t\t\treturn false; \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( type == 'first') { \n\t\t\t\t\t\treturn true; \n\t\t\t\t\t}\n\t\t\t\t\tnode = elem;\n\t\t\t\tcase 'last':\n\t\t\t\t\twhile ( (node = node.nextSibling) )\t {\n\t\t\t\t\t\tif ( node.nodeType === 1 ) { \n\t\t\t\t\t\t\treturn false; \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\tcase 'nth':\n\t\t\t\t\tvar first = match[2], last = match[3];\n\n\t\t\t\t\tif ( first == 1 && last == 0 ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar doneName = match[0],\n\t\t\t\t\t\tparent = elem.parentNode;\n\t\n\t\t\t\t\tif ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {\n\t\t\t\t\t\tvar count = 0;\n\t\t\t\t\t\tfor ( node = parent.firstChild; node; node = node.nextSibling ) {\n\t\t\t\t\t\t\tif ( node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\tnode.nodeIndex = ++count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} \n\t\t\t\t\t\tparent.sizcache = doneName;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar diff = elem.nodeIndex - last;\n\t\t\t\t\tif ( first == 0 ) {\n\t\t\t\t\t\treturn diff == 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn ( diff % first == 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t}\n\t\t}","jQuery.expr.filter.CLASS":"function (elem, match){\n\t\t\treturn (\" \" + (elem.className || elem.getAttribute(\"class\")) + \" \")\n\t\t\t\t.indexOf( match ) > -1;\n\t\t}","jQuery.expr.filter.ID":"function (elem, match){\n\t\t\treturn elem.nodeType === 1 && elem.getAttribute(\"id\") === match;\n\t\t}","jQuery.expr.filter.POS":"function (elem, match, i, array){\n\t\t\tvar name = match[2], filter = Expr.setFilters[ name ];\n\n\t\t\tif ( filter ) {\n\t\t\t\treturn filter( elem, i, match, array );\n\t\t\t}\n\t\t}","jQuery.expr.filter.PSEUDO":"function (elem, match, i, array){\n\t\t\tvar name = match[1], filter = Expr.filters[ name ];\n\n\t\t\tif ( filter ) {\n\t\t\t\treturn filter( elem, i, match, array );\n\t\t\t} else if ( name === \"contains\" ) {\n\t\t\t\treturn (elem.textContent || elem.innerText || getText([ elem ]) || \"\").indexOf(match[3]) >= 0;\n\t\t\t} else if ( name === \"not\" ) {\n\t\t\t\tvar not = match[3];\n\n\t\t\t\tfor ( var i = 0, l = not.length; i < l; i++ ) {\n\t\t\t\t\tif ( not[i] === elem ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}","jQuery.expr.filter.TAG":"function (elem, match){\n\t\t\treturn (match === \"*\" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match;\n\t\t}","jQuery.expr.filters.animated":"function (elem){\n\t\treturn jQuery.grep(jQuery.timers, function(fn){\n\t\t\treturn elem === fn.elem;\n\t\t}).length;\n\t}","jQuery.expr.filters.button":"function (elem){\n\t\t\treturn \"button\" === elem.type || elem.nodeName.toLowerCase() === \"button\";\n\t\t}","jQuery.expr.filters.checkbox":"function (elem){\n\t\t\treturn \"checkbox\" === elem.type;\n\t\t}","jQuery.expr.filters.checked":"function (elem){\n\t\t\treturn elem.checked === true;\n\t\t}","jQuery.expr.filters.disabled":"function (elem){\n\t\t\treturn elem.disabled === true;\n\t\t}","jQuery.expr.filters.empty":"function (elem){\n\t\t\treturn !elem.firstChild;\n\t\t}","jQuery.expr.filters.enabled":"function (elem){\n\t\t\treturn elem.disabled === false && elem.type !== \"hidden\";\n\t\t}","jQuery.expr.filters.file":"function (elem){\n\t\t\treturn \"file\" === elem.type;\n\t\t}","jQuery.expr.filters.has":"function (elem, i, match){\n\t\t\treturn !!Sizzle( match[3], elem ).length;\n\t\t}","jQuery.expr.filters.header":"function (elem){\n\t\t\treturn /h\\d/i.test( elem.nodeName );\n\t\t}","jQuery.expr.filters.hidden":"function ( elem ) {\n\t\tvar width = elem.offsetWidth, height = elem.offsetHeight,\n\t\t\tskip = elem.nodeName.toLowerCase() === \"tr\";\n\n\t\treturn width === 0 && height === 0 && !skip ?\n\t\t\ttrue :\n\t\t\twidth > 0 && height > 0 && !skip ?\n\t\t\t\tfalse :\n\t\t\t\tjQuery.curCSS(elem, \"display\") === \"none\";\n\t}","jQuery.expr.filters.image":"function (elem){\n\t\t\treturn \"image\" === elem.type;\n\t\t}","jQuery.expr.filters.input":"function (elem){\n\t\t\treturn /input|select|textarea|button/i.test(elem.nodeName);\n\t\t}","jQuery.expr.filters.parent":"function (elem){\n\t\t\treturn !!elem.firstChild;\n\t\t}","jQuery.expr.filters.password":"function (elem){\n\t\t\treturn \"password\" === elem.type;\n\t\t}","jQuery.expr.filters.radio":"function (elem){\n\t\t\treturn \"radio\" === elem.type;\n\t\t}","jQuery.expr.filters.reset":"function (elem){\n\t\t\treturn \"reset\" === elem.type;\n\t\t}","jQuery.expr.filters.selected":"function (elem){\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\telem.parentNode.selectedIndex;\n\t\t\treturn elem.selected === true;\n\t\t}","jQuery.expr.filters.submit":"function (elem){\n\t\t\treturn \"submit\" === elem.type;\n\t\t}","jQuery.expr.filters.text":"function (elem){\n\t\t\treturn \"text\" === elem.type;\n\t\t}","jQuery.expr.filters.visible":"function ( elem ) {\n\t\treturn !jQuery.expr.filters.hidden( elem );\n\t}","jQuery.expr.find.CLASS":"function (match, context, isXML) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && !isXML ) {\n\t\t\treturn context.getElementsByClassName(match[1]);\n\t\t}\n\t}","jQuery.expr.find.ID":"function (match, context, isXML){\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && !isXML ) {\n\t\t\t\tvar m = context.getElementById(match[1]);\n\t\t\t\treturn m ? [m] : [];\n\t\t\t}\n\t\t}","jQuery.expr.find.NAME":"function (match, context){\n\t\t\tif ( typeof context.getElementsByName !== \"undefined\" ) {\n\t\t\t\tvar ret = [], results = context.getElementsByName(match[1]);\n\n\t\t\t\tfor ( var i = 0, l = results.length; i < l; i++ ) {\n\t\t\t\t\tif ( results[i].getAttribute(\"name\") === match[1] ) {\n\t\t\t\t\t\tret.push( results[i] );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ret.length === 0 ? null : ret;\n\t\t\t}\n\t\t}","jQuery.expr.find.TAG":"function (match, context){\n\t\t\treturn context.getElementsByTagName(match[1]);\n\t\t}","jQuery.expr.preFilter.ATTR":"function (match, curLoop, inplace, result, not, isXML){\n\t\t\tvar name = match[1].replace(/\\\\/g, \"\");\n\t\t\t\n\t\t\tif ( !isXML && Expr.attrMap[name] ) {\n\t\t\t\tmatch[1] = Expr.attrMap[name];\n\t\t\t}\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[4] = \" \" + match[4] + \" \";\n\t\t\t}\n\n\t\t\treturn match;\n\t\t}","jQuery.expr.preFilter.CHILD":"function (match){\n\t\t\tif ( match[1] == \"nth\" ) {\n\t\t\t\t// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'\n\t\t\t\tvar test = /(-?)(\\d*)n((?:\\+|-)?\\d*)/.exec(\n\t\t\t\t\tmatch[2] == \"even\" && \"2n\" || match[2] == \"odd\" && \"2n+1\" ||\n\t\t\t\t\t!/\\D/.test( match[2] ) && \"0n+\" + match[2] || match[2]);\n\n\t\t\t\t// calculate the numbers (first)n+(last) including if they are negative\n\t\t\t\tmatch[2] = (test[1] + (test[2] || 1)) - 0;\n\t\t\t\tmatch[3] = test[3] - 0;\n\t\t\t}\n\n\t\t\t// TODO: Move to normal caching system\n\t\t\tmatch[0] = done++;\n\n\t\t\treturn match;\n\t\t}","jQuery.expr.preFilter.CLASS":"function (match, curLoop, inplace, result, not, isXML){\n\t\t\tmatch = \" \" + match[1].replace(/\\\\/g, \"\") + \" \";\n\n\t\t\tif ( isXML ) {\n\t\t\t\treturn match;\n\t\t\t}\n\n\t\t\tfor ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {\n\t\t\t\tif ( elem ) {\n\t\t\t\t\tif ( not ^ (elem.className && (\" \" + elem.className + \" \").replace(/[\\t\\n]/g, \" \").indexOf(match) >= 0) ) {\n\t\t\t\t\t\tif ( !inplace ) {\n\t\t\t\t\t\t\tresult.push( elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if ( inplace ) {\n\t\t\t\t\t\tcurLoop[i] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}","jQuery.expr.preFilter.ID":"function (match){\n\t\t\treturn match[1].replace(/\\\\/g, \"\");\n\t\t}","jQuery.expr.preFilter.POS":"function (match){\n\t\t\tmatch.unshift( true );\n\t\t\treturn match;\n\t\t}","jQuery.expr.preFilter.PSEUDO":"function (match, curLoop, inplace, result, not){\n\t\t\tif ( match[1] === \"not\" ) {\n\t\t\t\t// If we're dealing with a complex expression, or a simple one\n\t\t\t\tif ( ( chunker.exec(match[3]) || \"\" ).length > 1 || /^\\w/.test(match[3]) ) {\n\t\t\t\t\tmatch[3] = Sizzle(match[3], null, null, curLoop);\n\t\t\t\t} else {\n\t\t\t\t\tvar ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);\n\t\t\t\t\tif ( !inplace ) {\n\t\t\t\t\t\tresult.push.apply( result, ret );\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn match;\n\t\t}","jQuery.expr.preFilter.TAG":"function (match, curLoop){\n\t\t\treturn match[1].toLowerCase();\n\t\t}","jQuery.expr.relative.":"function (checkSet, part){\n\t\t\tvar doneName = done++, checkFn = dirCheck;\n\n\t\t\tif ( !/\\W/.test(part) ) {\n\t\t\t\tvar nodeCheck = part = part.toLowerCase();\n\t\t\t\tcheckFn = dirNodeCheck;\n\t\t\t}\n\n\t\t\tcheckFn(\"parentNode\", part, doneName, checkSet, nodeCheck, isXML);\n\t\t}","jQuery.expr.relative.+":"function (checkSet, part){\n\t\t\tvar isPartStr = typeof part === \"string\",\n\t\t\t\tisTag = isPartStr && !/\\W/.test(part),\n\t\t\t\tisPartStrNotTag = isPartStr && !isTag;\n\n\t\t\tif ( isTag ) {\n\t\t\t\tpart = part.toLowerCase();\n\t\t\t}\n\n\t\t\tfor ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {\n\t\t\t\tif ( (elem = checkSet[i]) ) {\n\t\t\t\t\twhile ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}\n\n\t\t\t\t\tcheckSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?\n\t\t\t\t\t\telem || false :\n\t\t\t\t\t\telem === part;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( isPartStrNotTag ) {\n\t\t\t\tSizzle.filter( part, checkSet, true );\n\t\t\t}\n\t\t}","jQuery.expr.relative.>":"function (checkSet, part){\n\t\t\tvar isPartStr = typeof part === \"string\";\n\n\t\t\tif ( isPartStr && !/\\W/.test(part) ) {\n\t\t\t\tpart = part.toLowerCase();\n\n\t\t\t\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\t\t\t\tvar elem = checkSet[i];\n\t\t\t\t\tif ( elem ) {\n\t\t\t\t\t\tvar parent = elem.parentNode;\n\t\t\t\t\t\tcheckSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\t\t\t\tvar elem = checkSet[i];\n\t\t\t\t\tif ( elem ) {\n\t\t\t\t\t\tcheckSet[i] = isPartStr ?\n\t\t\t\t\t\t\telem.parentNode :\n\t\t\t\t\t\t\telem.parentNode === part;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( isPartStr ) {\n\t\t\t\t\tSizzle.filter( part, checkSet, true );\n\t\t\t\t}\n\t\t\t}\n\t\t}","jQuery.expr.relative.~":"function (checkSet, part){\n\t\t\tvar doneName = done++, checkFn = dirCheck;\n\n\t\t\tif ( typeof part === \"string\" && !/\\W/.test(part) ) {\n\t\t\t\tvar nodeCheck = part = part.toLowerCase();\n\t\t\t\tcheckFn = dirNodeCheck;\n\t\t\t}\n\n\t\t\tcheckFn(\"previousSibling\", part, doneName, checkSet, nodeCheck, isXML);\n\t\t}","jQuery.expr.setFilters.eq":"function (elem, i, match){\n\t\t\treturn match[3] - 0 == i;\n\t\t}","jQuery.expr.setFilters.even":"function (elem, i){\n\t\t\treturn i % 2 === 0;\n\t\t}","jQuery.expr.setFilters.first":"function (elem, i){\n\t\t\treturn i === 0;\n\t\t}","jQuery.expr.setFilters.gt":"function (elem, i, match){\n\t\t\treturn i > match[3] - 0;\n\t\t}","jQuery.expr.setFilters.last":"function (elem, i, match, array){\n\t\t\treturn i === array.length - 1;\n\t\t}","jQuery.expr.setFilters.lt":"function (elem, i, match){\n\t\t\treturn i < match[3] - 0;\n\t\t}","jQuery.expr.setFilters.nth":"function (elem, i, match){\n\t\t\treturn match[3] - 0 == i;\n\t\t}","jQuery.expr.setFilters.odd":"function (elem, i){\n\t\t\treturn i % 2 === 1;\n\t\t}","jQuery.event.special.beforeunload.setup":"function ( data, namespaces, fn ) {\n\t\t\t\t// We only want to do this special case on windows\n\t\t\t\tif ( this.setInterval ) {\n\t\t\t\t\tthis.onbeforeunload = fn;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}","jQuery.event.special.beforeunload.teardown":"function ( namespaces, fn ) {\n\t\t\t\tif ( this.onbeforeunload === fn ) {\n\t\t\t\t\tthis.onbeforeunload = null;\n\t\t\t\t}\n\t\t\t}","jQuery.event.special.live.add":"function ( proxy, data, namespaces, live ) {\n\t\t\t\tjQuery.extend( proxy, data || {} );\n\n\t\t\t\tproxy.guid += data.selector + data.live; \n\t\t\t\tjQuery.event.add( this, data.live, liveHandler, data ); \n\t\t\t\t\n\t\t\t}","jQuery.event.special.live.remove":"function ( namespaces ) {\n\t\t\t\tif ( namespaces.length ) {\n\t\t\t\t\tvar remove = 0, name = new RegExp(\"(^|\\\\.)\" + namespaces[0] + \"(\\\\.|$)\");\n\n\t\t\t\t\tjQuery.each( (jQuery.data(this, \"events\").live || {}), function() {\n\t\t\t\t\t\tif ( name.test(this.type) ) {\n\t\t\t\t\t\t\tremove++;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tif ( remove < 1 ) {\n\t\t\t\t\t\tjQuery.event.remove( this, namespaces[0], liveHandler );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}","jQuery.event.special.mouseenter.setup":"function (data){\n\t\t\tjQuery.event.add( this, fix, data && data.selector ? delegate : withinElement, orig );\n\t\t}","jQuery.event.special.mouseenter.teardown":"function (data){\n\t\t\tjQuery.event.remove( this, fix, data && data.selector ? delegate : withinElement );\n\t\t}","jQuery.event.special.mouseleave.setup":"function (data){\n\t\t\tjQuery.event.add( this, fix, data && data.selector ? delegate : withinElement, orig );\n\t\t}","jQuery.event.special.mouseleave.teardown":"function (data){\n\t\t\tjQuery.event.remove( this, fix, data && data.selector ? delegate : withinElement );\n\t\t}","jQuery.event.special.ready.setup":"function () {\n\t\tif ( readyBound ) { return; }\n\t\treadyBound = true;\n\n\t\t// Catch cases where $(document).ready() is called after the\n\t\t// browser event has already occurred.\n\t\tif ( document.readyState === \"complete\" ) {\n\t\t\treturn jQuery.ready();\n\t\t}\n\n\t\t// Mozilla, Opera and webkit nightlies currently support this event\n\t\tif ( document.addEventListener ) {\n\t\t\t// Use the handy event callback\n\t\t\tdocument.addEventListener( \"DOMContentLoaded\", DOMContentLoaded, false );\n\t\t\t\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.addEventListener( \"load\", jQuery.ready, false );\n\n\t\t// If IE event model is used\n\t\t} else if ( document.attachEvent ) {\n\t\t\t// ensure firing before onload,\n\t\t\t// maybe late but safe also for iframes\n\t\t\tdocument.attachEvent(\"onreadystatechange\", DOMContentLoaded);\n\t\t\t\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.attachEvent( \"onload\", jQuery.ready );\n\n\t\t\t// If IE and not a frame\n\t\t\t// continually check to see if the document is ready\n\t\t\tvar toplevel = false;\n\n\t\t\ttry {\n\t\t\t\ttoplevel = window.frameElement == null;\n\t\t\t} catch(e){}\n\n\t\t\tif ( document.documentElement.doScroll && toplevel ) {\n\t\t\t\tdoScrollCheck();\n\t\t\t}\n\t\t}\n\t}","jQuery.event.special.ready.teardown":"function () {}"}